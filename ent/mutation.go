// Code generated by ent, DO NOT EDIT.

package ent

import (
	"authorization-service/ent/accesstokens"
	"authorization-service/ent/authorizecodes"
	"authorization-service/ent/blacklistedjtis"
	"authorization-service/ent/clients"
	"authorization-service/ent/idsessions"
	"authorization-service/ent/issuerpublickeys"
	"authorization-service/ent/pkces"
	"authorization-service/ent/predicate"
	"authorization-service/ent/publickeyscopes"
	"authorization-service/ent/refreshtokens"
	"authorization-service/ent/request"
	"authorization-service/ent/session"
	"authorization-service/ent/subjectpublickeys"
	"authorization-service/ent/user"
	"context"
	"errors"
	"fmt"
	"net/url"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"golang.org/x/text/language"
	jose "gopkg.in/square/go-jose.v2"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessTokens      = "AccessTokens"
	TypeAuthorizeCodes    = "AuthorizeCodes"
	TypeBlacklistedJTIs   = "BlacklistedJTIs"
	TypeClients           = "Clients"
	TypeIDSessions        = "IDSessions"
	TypeIssuerPublicKeys  = "IssuerPublicKeys"
	TypePKCES             = "PKCES"
	TypePublicKeyScopes   = "PublicKeyScopes"
	TypeRefreshTokens     = "RefreshTokens"
	TypeRequest           = "Request"
	TypeSession           = "Session"
	TypeSubjectPublicKeys = "SubjectPublicKeys"
	TypeUser              = "User"
)

// AccessTokensMutation represents an operation that mutates the AccessTokens nodes in the graph.
type AccessTokensMutation struct {
	config
	op                Op
	typ               string
	id                *string
	clearedFields     map[string]struct{}
	request_id        *string
	clearedrequest_id bool
	done              bool
	oldValue          func(context.Context) (*AccessTokens, error)
	predicates        []predicate.AccessTokens
}

var _ ent.Mutation = (*AccessTokensMutation)(nil)

// accesstokensOption allows management of the mutation configuration using functional options.
type accesstokensOption func(*AccessTokensMutation)

// newAccessTokensMutation creates new mutation for the AccessTokens entity.
func newAccessTokensMutation(c config, op Op, opts ...accesstokensOption) *AccessTokensMutation {
	m := &AccessTokensMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessTokens,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessTokensID sets the ID field of the mutation.
func withAccessTokensID(id string) accesstokensOption {
	return func(m *AccessTokensMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessTokens
		)
		m.oldValue = func(ctx context.Context) (*AccessTokens, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessTokens.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessTokens sets the old AccessTokens of the mutation.
func withAccessTokens(node *AccessTokens) accesstokensOption {
	return func(m *AccessTokensMutation) {
		m.oldValue = func(context.Context) (*AccessTokens, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessTokensMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessTokensMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccessTokens entities.
func (m *AccessTokensMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessTokensMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessTokensMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessTokens.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestIDID sets the "request_id" edge to the Request entity by id.
func (m *AccessTokensMutation) SetRequestIDID(id string) {
	m.request_id = &id
}

// ClearRequestID clears the "request_id" edge to the Request entity.
func (m *AccessTokensMutation) ClearRequestID() {
	m.clearedrequest_id = true
}

// RequestIDCleared reports if the "request_id" edge to the Request entity was cleared.
func (m *AccessTokensMutation) RequestIDCleared() bool {
	return m.clearedrequest_id
}

// RequestIDID returns the "request_id" edge ID in the mutation.
func (m *AccessTokensMutation) RequestIDID() (id string, exists bool) {
	if m.request_id != nil {
		return *m.request_id, true
	}
	return
}

// RequestIDIDs returns the "request_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestIDID instead. It exists only for internal usage by the builders.
func (m *AccessTokensMutation) RequestIDIDs() (ids []string) {
	if id := m.request_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestID resets all changes to the "request_id" edge.
func (m *AccessTokensMutation) ResetRequestID() {
	m.request_id = nil
	m.clearedrequest_id = false
}

// Where appends a list predicates to the AccessTokensMutation builder.
func (m *AccessTokensMutation) Where(ps ...predicate.AccessTokens) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessTokensMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessTokensMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessTokens, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessTokensMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessTokensMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessTokens).
func (m *AccessTokensMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessTokensMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessTokensMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessTokensMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AccessTokens field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokensMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessTokens field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessTokensMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessTokensMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokensMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AccessTokens numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessTokensMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessTokensMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessTokensMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccessTokens nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessTokensMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AccessTokens field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessTokensMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.request_id != nil {
		edges = append(edges, accesstokens.EdgeRequestID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessTokensMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accesstokens.EdgeRequestID:
		if id := m.request_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessTokensMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessTokensMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessTokensMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequest_id {
		edges = append(edges, accesstokens.EdgeRequestID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessTokensMutation) EdgeCleared(name string) bool {
	switch name {
	case accesstokens.EdgeRequestID:
		return m.clearedrequest_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessTokensMutation) ClearEdge(name string) error {
	switch name {
	case accesstokens.EdgeRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown AccessTokens unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessTokensMutation) ResetEdge(name string) error {
	switch name {
	case accesstokens.EdgeRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown AccessTokens edge %s", name)
}

// AuthorizeCodesMutation represents an operation that mutates the AuthorizeCodes nodes in the graph.
type AuthorizeCodesMutation struct {
	config
	op                Op
	typ               string
	id                *string
	active            *bool
	clearedFields     map[string]struct{}
	request_id        *string
	clearedrequest_id bool
	done              bool
	oldValue          func(context.Context) (*AuthorizeCodes, error)
	predicates        []predicate.AuthorizeCodes
}

var _ ent.Mutation = (*AuthorizeCodesMutation)(nil)

// authorizecodesOption allows management of the mutation configuration using functional options.
type authorizecodesOption func(*AuthorizeCodesMutation)

// newAuthorizeCodesMutation creates new mutation for the AuthorizeCodes entity.
func newAuthorizeCodesMutation(c config, op Op, opts ...authorizecodesOption) *AuthorizeCodesMutation {
	m := &AuthorizeCodesMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthorizeCodes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthorizeCodesID sets the ID field of the mutation.
func withAuthorizeCodesID(id string) authorizecodesOption {
	return func(m *AuthorizeCodesMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthorizeCodes
		)
		m.oldValue = func(ctx context.Context) (*AuthorizeCodes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthorizeCodes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthorizeCodes sets the old AuthorizeCodes of the mutation.
func withAuthorizeCodes(node *AuthorizeCodes) authorizecodesOption {
	return func(m *AuthorizeCodesMutation) {
		m.oldValue = func(context.Context) (*AuthorizeCodes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthorizeCodesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthorizeCodesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthorizeCodes entities.
func (m *AuthorizeCodesMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthorizeCodesMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthorizeCodesMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthorizeCodes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActive sets the "active" field.
func (m *AuthorizeCodesMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *AuthorizeCodesMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the AuthorizeCodes entity.
// If the AuthorizeCodes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthorizeCodesMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *AuthorizeCodesMutation) ResetActive() {
	m.active = nil
}

// SetRequestIDID sets the "request_id" edge to the Request entity by id.
func (m *AuthorizeCodesMutation) SetRequestIDID(id string) {
	m.request_id = &id
}

// ClearRequestID clears the "request_id" edge to the Request entity.
func (m *AuthorizeCodesMutation) ClearRequestID() {
	m.clearedrequest_id = true
}

// RequestIDCleared reports if the "request_id" edge to the Request entity was cleared.
func (m *AuthorizeCodesMutation) RequestIDCleared() bool {
	return m.clearedrequest_id
}

// RequestIDID returns the "request_id" edge ID in the mutation.
func (m *AuthorizeCodesMutation) RequestIDID() (id string, exists bool) {
	if m.request_id != nil {
		return *m.request_id, true
	}
	return
}

// RequestIDIDs returns the "request_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestIDID instead. It exists only for internal usage by the builders.
func (m *AuthorizeCodesMutation) RequestIDIDs() (ids []string) {
	if id := m.request_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestID resets all changes to the "request_id" edge.
func (m *AuthorizeCodesMutation) ResetRequestID() {
	m.request_id = nil
	m.clearedrequest_id = false
}

// Where appends a list predicates to the AuthorizeCodesMutation builder.
func (m *AuthorizeCodesMutation) Where(ps ...predicate.AuthorizeCodes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthorizeCodesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthorizeCodesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthorizeCodes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthorizeCodesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthorizeCodesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthorizeCodes).
func (m *AuthorizeCodesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthorizeCodesMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.active != nil {
		fields = append(fields, authorizecodes.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthorizeCodesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authorizecodes.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthorizeCodesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authorizecodes.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown AuthorizeCodes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizeCodesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authorizecodes.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown AuthorizeCodes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthorizeCodesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthorizeCodesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthorizeCodesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthorizeCodes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthorizeCodesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthorizeCodesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthorizeCodesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthorizeCodes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthorizeCodesMutation) ResetField(name string) error {
	switch name {
	case authorizecodes.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown AuthorizeCodes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthorizeCodesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.request_id != nil {
		edges = append(edges, authorizecodes.EdgeRequestID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthorizeCodesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case authorizecodes.EdgeRequestID:
		if id := m.request_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthorizeCodesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthorizeCodesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthorizeCodesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequest_id {
		edges = append(edges, authorizecodes.EdgeRequestID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthorizeCodesMutation) EdgeCleared(name string) bool {
	switch name {
	case authorizecodes.EdgeRequestID:
		return m.clearedrequest_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthorizeCodesMutation) ClearEdge(name string) error {
	switch name {
	case authorizecodes.EdgeRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown AuthorizeCodes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthorizeCodesMutation) ResetEdge(name string) error {
	switch name {
	case authorizecodes.EdgeRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown AuthorizeCodes edge %s", name)
}

// BlacklistedJTIsMutation represents an operation that mutates the BlacklistedJTIs nodes in the graph.
type BlacklistedJTIsMutation struct {
	config
	op            Op
	typ           string
	id            *string
	expiry        *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlacklistedJTIs, error)
	predicates    []predicate.BlacklistedJTIs
}

var _ ent.Mutation = (*BlacklistedJTIsMutation)(nil)

// blacklistedjtisOption allows management of the mutation configuration using functional options.
type blacklistedjtisOption func(*BlacklistedJTIsMutation)

// newBlacklistedJTIsMutation creates new mutation for the BlacklistedJTIs entity.
func newBlacklistedJTIsMutation(c config, op Op, opts ...blacklistedjtisOption) *BlacklistedJTIsMutation {
	m := &BlacklistedJTIsMutation{
		config:        c,
		op:            op,
		typ:           TypeBlacklistedJTIs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlacklistedJTIsID sets the ID field of the mutation.
func withBlacklistedJTIsID(id string) blacklistedjtisOption {
	return func(m *BlacklistedJTIsMutation) {
		var (
			err   error
			once  sync.Once
			value *BlacklistedJTIs
		)
		m.oldValue = func(ctx context.Context) (*BlacklistedJTIs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlacklistedJTIs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlacklistedJTIs sets the old BlacklistedJTIs of the mutation.
func withBlacklistedJTIs(node *BlacklistedJTIs) blacklistedjtisOption {
	return func(m *BlacklistedJTIsMutation) {
		m.oldValue = func(context.Context) (*BlacklistedJTIs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlacklistedJTIsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlacklistedJTIsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlacklistedJTIs entities.
func (m *BlacklistedJTIsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlacklistedJTIsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlacklistedJTIsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlacklistedJTIs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpiry sets the "expiry" field.
func (m *BlacklistedJTIsMutation) SetExpiry(t time.Time) {
	m.expiry = &t
}

// Expiry returns the value of the "expiry" field in the mutation.
func (m *BlacklistedJTIsMutation) Expiry() (r time.Time, exists bool) {
	v := m.expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiry returns the old "expiry" field's value of the BlacklistedJTIs entity.
// If the BlacklistedJTIs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistedJTIsMutation) OldExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiry: %w", err)
	}
	return oldValue.Expiry, nil
}

// ResetExpiry resets all changes to the "expiry" field.
func (m *BlacklistedJTIsMutation) ResetExpiry() {
	m.expiry = nil
}

// Where appends a list predicates to the BlacklistedJTIsMutation builder.
func (m *BlacklistedJTIsMutation) Where(ps ...predicate.BlacklistedJTIs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlacklistedJTIsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlacklistedJTIsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlacklistedJTIs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlacklistedJTIsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlacklistedJTIsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlacklistedJTIs).
func (m *BlacklistedJTIsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlacklistedJTIsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.expiry != nil {
		fields = append(fields, blacklistedjtis.FieldExpiry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlacklistedJTIsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blacklistedjtis.FieldExpiry:
		return m.Expiry()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlacklistedJTIsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blacklistedjtis.FieldExpiry:
		return m.OldExpiry(ctx)
	}
	return nil, fmt.Errorf("unknown BlacklistedJTIs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlacklistedJTIsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blacklistedjtis.FieldExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiry(v)
		return nil
	}
	return fmt.Errorf("unknown BlacklistedJTIs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlacklistedJTIsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlacklistedJTIsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlacklistedJTIsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BlacklistedJTIs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlacklistedJTIsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlacklistedJTIsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlacklistedJTIsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlacklistedJTIs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlacklistedJTIsMutation) ResetField(name string) error {
	switch name {
	case blacklistedjtis.FieldExpiry:
		m.ResetExpiry()
		return nil
	}
	return fmt.Errorf("unknown BlacklistedJTIs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlacklistedJTIsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlacklistedJTIsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlacklistedJTIsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlacklistedJTIsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlacklistedJTIsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlacklistedJTIsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlacklistedJTIsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlacklistedJTIs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlacklistedJTIsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlacklistedJTIs edge %s", name)
}

// ClientsMutation represents an operation that mutates the Clients nodes in the graph.
type ClientsMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	client_secret         *[]byte
	rotated_secrets       *[][]uint8
	appendrotated_secrets [][]uint8
	redirect_uris         *[]string
	appendredirect_uris   []string
	grant_types           *[]string
	appendgrant_types     []string
	response_types        *[]string
	appendresponse_types  []string
	scopes                *[]string
	appendscopes          []string
	audience              *[]string
	appendaudience        []string
	public                *bool
	clearedFields         map[string]struct{}
	requests              map[string]struct{}
	removedrequests       map[string]struct{}
	clearedrequests       bool
	done                  bool
	oldValue              func(context.Context) (*Clients, error)
	predicates            []predicate.Clients
}

var _ ent.Mutation = (*ClientsMutation)(nil)

// clientsOption allows management of the mutation configuration using functional options.
type clientsOption func(*ClientsMutation)

// newClientsMutation creates new mutation for the Clients entity.
func newClientsMutation(c config, op Op, opts ...clientsOption) *ClientsMutation {
	m := &ClientsMutation{
		config:        c,
		op:            op,
		typ:           TypeClients,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClientsID sets the ID field of the mutation.
func withClientsID(id string) clientsOption {
	return func(m *ClientsMutation) {
		var (
			err   error
			once  sync.Once
			value *Clients
		)
		m.oldValue = func(ctx context.Context) (*Clients, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Clients.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClients sets the old Clients of the mutation.
func withClients(node *Clients) clientsOption {
	return func(m *ClientsMutation) {
		m.oldValue = func(context.Context) (*Clients, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClientsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClientsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Clients entities.
func (m *ClientsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClientsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClientsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Clients.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientSecret sets the "client_secret" field.
func (m *ClientsMutation) SetClientSecret(b []byte) {
	m.client_secret = &b
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *ClientsMutation) ClientSecret() (r []byte, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldClientSecret(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *ClientsMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetRotatedSecrets sets the "rotated_secrets" field.
func (m *ClientsMutation) SetRotatedSecrets(u [][]uint8) {
	m.rotated_secrets = &u
	m.appendrotated_secrets = nil
}

// RotatedSecrets returns the value of the "rotated_secrets" field in the mutation.
func (m *ClientsMutation) RotatedSecrets() (r [][]uint8, exists bool) {
	v := m.rotated_secrets
	if v == nil {
		return
	}
	return *v, true
}

// OldRotatedSecrets returns the old "rotated_secrets" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldRotatedSecrets(ctx context.Context) (v [][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRotatedSecrets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRotatedSecrets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRotatedSecrets: %w", err)
	}
	return oldValue.RotatedSecrets, nil
}

// AppendRotatedSecrets adds u to the "rotated_secrets" field.
func (m *ClientsMutation) AppendRotatedSecrets(u [][]uint8) {
	m.appendrotated_secrets = append(m.appendrotated_secrets, u...)
}

// AppendedRotatedSecrets returns the list of values that were appended to the "rotated_secrets" field in this mutation.
func (m *ClientsMutation) AppendedRotatedSecrets() ([][]uint8, bool) {
	if len(m.appendrotated_secrets) == 0 {
		return nil, false
	}
	return m.appendrotated_secrets, true
}

// ResetRotatedSecrets resets all changes to the "rotated_secrets" field.
func (m *ClientsMutation) ResetRotatedSecrets() {
	m.rotated_secrets = nil
	m.appendrotated_secrets = nil
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *ClientsMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *ClientsMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *ClientsMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *ClientsMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *ClientsMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
}

// SetGrantTypes sets the "grant_types" field.
func (m *ClientsMutation) SetGrantTypes(s []string) {
	m.grant_types = &s
	m.appendgrant_types = nil
}

// GrantTypes returns the value of the "grant_types" field in the mutation.
func (m *ClientsMutation) GrantTypes() (r []string, exists bool) {
	v := m.grant_types
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantTypes returns the old "grant_types" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldGrantTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantTypes: %w", err)
	}
	return oldValue.GrantTypes, nil
}

// AppendGrantTypes adds s to the "grant_types" field.
func (m *ClientsMutation) AppendGrantTypes(s []string) {
	m.appendgrant_types = append(m.appendgrant_types, s...)
}

// AppendedGrantTypes returns the list of values that were appended to the "grant_types" field in this mutation.
func (m *ClientsMutation) AppendedGrantTypes() ([]string, bool) {
	if len(m.appendgrant_types) == 0 {
		return nil, false
	}
	return m.appendgrant_types, true
}

// ResetGrantTypes resets all changes to the "grant_types" field.
func (m *ClientsMutation) ResetGrantTypes() {
	m.grant_types = nil
	m.appendgrant_types = nil
}

// SetResponseTypes sets the "response_types" field.
func (m *ClientsMutation) SetResponseTypes(s []string) {
	m.response_types = &s
	m.appendresponse_types = nil
}

// ResponseTypes returns the value of the "response_types" field in the mutation.
func (m *ClientsMutation) ResponseTypes() (r []string, exists bool) {
	v := m.response_types
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseTypes returns the old "response_types" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldResponseTypes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseTypes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseTypes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseTypes: %w", err)
	}
	return oldValue.ResponseTypes, nil
}

// AppendResponseTypes adds s to the "response_types" field.
func (m *ClientsMutation) AppendResponseTypes(s []string) {
	m.appendresponse_types = append(m.appendresponse_types, s...)
}

// AppendedResponseTypes returns the list of values that were appended to the "response_types" field in this mutation.
func (m *ClientsMutation) AppendedResponseTypes() ([]string, bool) {
	if len(m.appendresponse_types) == 0 {
		return nil, false
	}
	return m.appendresponse_types, true
}

// ResetResponseTypes resets all changes to the "response_types" field.
func (m *ClientsMutation) ResetResponseTypes() {
	m.response_types = nil
	m.appendresponse_types = nil
}

// SetScopes sets the "scopes" field.
func (m *ClientsMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ClientsMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ClientsMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ClientsMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ClientsMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetAudience sets the "audience" field.
func (m *ClientsMutation) SetAudience(s []string) {
	m.audience = &s
	m.appendaudience = nil
}

// Audience returns the value of the "audience" field in the mutation.
func (m *ClientsMutation) Audience() (r []string, exists bool) {
	v := m.audience
	if v == nil {
		return
	}
	return *v, true
}

// OldAudience returns the old "audience" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldAudience(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudience: %w", err)
	}
	return oldValue.Audience, nil
}

// AppendAudience adds s to the "audience" field.
func (m *ClientsMutation) AppendAudience(s []string) {
	m.appendaudience = append(m.appendaudience, s...)
}

// AppendedAudience returns the list of values that were appended to the "audience" field in this mutation.
func (m *ClientsMutation) AppendedAudience() ([]string, bool) {
	if len(m.appendaudience) == 0 {
		return nil, false
	}
	return m.appendaudience, true
}

// ClearAudience clears the value of the "audience" field.
func (m *ClientsMutation) ClearAudience() {
	m.audience = nil
	m.appendaudience = nil
	m.clearedFields[clients.FieldAudience] = struct{}{}
}

// AudienceCleared returns if the "audience" field was cleared in this mutation.
func (m *ClientsMutation) AudienceCleared() bool {
	_, ok := m.clearedFields[clients.FieldAudience]
	return ok
}

// ResetAudience resets all changes to the "audience" field.
func (m *ClientsMutation) ResetAudience() {
	m.audience = nil
	m.appendaudience = nil
	delete(m.clearedFields, clients.FieldAudience)
}

// SetPublic sets the "public" field.
func (m *ClientsMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *ClientsMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Clients entity.
// If the Clients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClientsMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ClearPublic clears the value of the "public" field.
func (m *ClientsMutation) ClearPublic() {
	m.public = nil
	m.clearedFields[clients.FieldPublic] = struct{}{}
}

// PublicCleared returns if the "public" field was cleared in this mutation.
func (m *ClientsMutation) PublicCleared() bool {
	_, ok := m.clearedFields[clients.FieldPublic]
	return ok
}

// ResetPublic resets all changes to the "public" field.
func (m *ClientsMutation) ResetPublic() {
	m.public = nil
	delete(m.clearedFields, clients.FieldPublic)
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *ClientsMutation) AddRequestIDs(ids ...string) {
	if m.requests == nil {
		m.requests = make(map[string]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *ClientsMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *ClientsMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *ClientsMutation) RemoveRequestIDs(ids ...string) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *ClientsMutation) RemovedRequestsIDs() (ids []string) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *ClientsMutation) RequestsIDs() (ids []string) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *ClientsMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the ClientsMutation builder.
func (m *ClientsMutation) Where(ps ...predicate.Clients) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClientsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClientsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Clients, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClientsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClientsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Clients).
func (m *ClientsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClientsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.client_secret != nil {
		fields = append(fields, clients.FieldClientSecret)
	}
	if m.rotated_secrets != nil {
		fields = append(fields, clients.FieldRotatedSecrets)
	}
	if m.redirect_uris != nil {
		fields = append(fields, clients.FieldRedirectUris)
	}
	if m.grant_types != nil {
		fields = append(fields, clients.FieldGrantTypes)
	}
	if m.response_types != nil {
		fields = append(fields, clients.FieldResponseTypes)
	}
	if m.scopes != nil {
		fields = append(fields, clients.FieldScopes)
	}
	if m.audience != nil {
		fields = append(fields, clients.FieldAudience)
	}
	if m.public != nil {
		fields = append(fields, clients.FieldPublic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClientsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clients.FieldClientSecret:
		return m.ClientSecret()
	case clients.FieldRotatedSecrets:
		return m.RotatedSecrets()
	case clients.FieldRedirectUris:
		return m.RedirectUris()
	case clients.FieldGrantTypes:
		return m.GrantTypes()
	case clients.FieldResponseTypes:
		return m.ResponseTypes()
	case clients.FieldScopes:
		return m.Scopes()
	case clients.FieldAudience:
		return m.Audience()
	case clients.FieldPublic:
		return m.Public()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClientsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clients.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case clients.FieldRotatedSecrets:
		return m.OldRotatedSecrets(ctx)
	case clients.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case clients.FieldGrantTypes:
		return m.OldGrantTypes(ctx)
	case clients.FieldResponseTypes:
		return m.OldResponseTypes(ctx)
	case clients.FieldScopes:
		return m.OldScopes(ctx)
	case clients.FieldAudience:
		return m.OldAudience(ctx)
	case clients.FieldPublic:
		return m.OldPublic(ctx)
	}
	return nil, fmt.Errorf("unknown Clients field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clients.FieldClientSecret:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case clients.FieldRotatedSecrets:
		v, ok := value.([][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRotatedSecrets(v)
		return nil
	case clients.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case clients.FieldGrantTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantTypes(v)
		return nil
	case clients.FieldResponseTypes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseTypes(v)
		return nil
	case clients.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case clients.FieldAudience:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudience(v)
		return nil
	case clients.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	}
	return fmt.Errorf("unknown Clients field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClientsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClientsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClientsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Clients numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClientsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clients.FieldAudience) {
		fields = append(fields, clients.FieldAudience)
	}
	if m.FieldCleared(clients.FieldPublic) {
		fields = append(fields, clients.FieldPublic)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClientsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClientsMutation) ClearField(name string) error {
	switch name {
	case clients.FieldAudience:
		m.ClearAudience()
		return nil
	case clients.FieldPublic:
		m.ClearPublic()
		return nil
	}
	return fmt.Errorf("unknown Clients nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClientsMutation) ResetField(name string) error {
	switch name {
	case clients.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case clients.FieldRotatedSecrets:
		m.ResetRotatedSecrets()
		return nil
	case clients.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case clients.FieldGrantTypes:
		m.ResetGrantTypes()
		return nil
	case clients.FieldResponseTypes:
		m.ResetResponseTypes()
		return nil
	case clients.FieldScopes:
		m.ResetScopes()
		return nil
	case clients.FieldAudience:
		m.ResetAudience()
		return nil
	case clients.FieldPublic:
		m.ResetPublic()
		return nil
	}
	return fmt.Errorf("unknown Clients field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClientsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.requests != nil {
		edges = append(edges, clients.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClientsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clients.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClientsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrequests != nil {
		edges = append(edges, clients.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClientsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clients.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClientsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequests {
		edges = append(edges, clients.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClientsMutation) EdgeCleared(name string) bool {
	switch name {
	case clients.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClientsMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Clients unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClientsMutation) ResetEdge(name string) error {
	switch name {
	case clients.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Clients edge %s", name)
}

// IDSessionsMutation represents an operation that mutates the IDSessions nodes in the graph.
type IDSessionsMutation struct {
	config
	op                Op
	typ               string
	id                *string
	clearedFields     map[string]struct{}
	request_id        *string
	clearedrequest_id bool
	done              bool
	oldValue          func(context.Context) (*IDSessions, error)
	predicates        []predicate.IDSessions
}

var _ ent.Mutation = (*IDSessionsMutation)(nil)

// idsessionsOption allows management of the mutation configuration using functional options.
type idsessionsOption func(*IDSessionsMutation)

// newIDSessionsMutation creates new mutation for the IDSessions entity.
func newIDSessionsMutation(c config, op Op, opts ...idsessionsOption) *IDSessionsMutation {
	m := &IDSessionsMutation{
		config:        c,
		op:            op,
		typ:           TypeIDSessions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIDSessionsID sets the ID field of the mutation.
func withIDSessionsID(id string) idsessionsOption {
	return func(m *IDSessionsMutation) {
		var (
			err   error
			once  sync.Once
			value *IDSessions
		)
		m.oldValue = func(ctx context.Context) (*IDSessions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IDSessions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIDSessions sets the old IDSessions of the mutation.
func withIDSessions(node *IDSessions) idsessionsOption {
	return func(m *IDSessionsMutation) {
		m.oldValue = func(context.Context) (*IDSessions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IDSessionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IDSessionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IDSessions entities.
func (m *IDSessionsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IDSessionsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IDSessionsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IDSessions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestIDID sets the "request_id" edge to the Request entity by id.
func (m *IDSessionsMutation) SetRequestIDID(id string) {
	m.request_id = &id
}

// ClearRequestID clears the "request_id" edge to the Request entity.
func (m *IDSessionsMutation) ClearRequestID() {
	m.clearedrequest_id = true
}

// RequestIDCleared reports if the "request_id" edge to the Request entity was cleared.
func (m *IDSessionsMutation) RequestIDCleared() bool {
	return m.clearedrequest_id
}

// RequestIDID returns the "request_id" edge ID in the mutation.
func (m *IDSessionsMutation) RequestIDID() (id string, exists bool) {
	if m.request_id != nil {
		return *m.request_id, true
	}
	return
}

// RequestIDIDs returns the "request_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestIDID instead. It exists only for internal usage by the builders.
func (m *IDSessionsMutation) RequestIDIDs() (ids []string) {
	if id := m.request_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestID resets all changes to the "request_id" edge.
func (m *IDSessionsMutation) ResetRequestID() {
	m.request_id = nil
	m.clearedrequest_id = false
}

// Where appends a list predicates to the IDSessionsMutation builder.
func (m *IDSessionsMutation) Where(ps ...predicate.IDSessions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IDSessionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IDSessionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IDSessions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IDSessionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IDSessionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IDSessions).
func (m *IDSessionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IDSessionsMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IDSessionsMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IDSessionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown IDSessions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IDSessionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IDSessions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IDSessionsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IDSessionsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IDSessionsMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown IDSessions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IDSessionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IDSessionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IDSessionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IDSessions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IDSessionsMutation) ResetField(name string) error {
	return fmt.Errorf("unknown IDSessions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IDSessionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.request_id != nil {
		edges = append(edges, idsessions.EdgeRequestID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IDSessionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case idsessions.EdgeRequestID:
		if id := m.request_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IDSessionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IDSessionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IDSessionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequest_id {
		edges = append(edges, idsessions.EdgeRequestID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IDSessionsMutation) EdgeCleared(name string) bool {
	switch name {
	case idsessions.EdgeRequestID:
		return m.clearedrequest_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IDSessionsMutation) ClearEdge(name string) error {
	switch name {
	case idsessions.EdgeRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown IDSessions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IDSessionsMutation) ResetEdge(name string) error {
	switch name {
	case idsessions.EdgeRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown IDSessions edge %s", name)
}

// IssuerPublicKeysMutation represents an operation that mutates the IssuerPublicKeys nodes in the graph.
type IssuerPublicKeysMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	clearedFields             map[string]struct{}
	subject_public_key        *string
	clearedsubject_public_key bool
	done                      bool
	oldValue                  func(context.Context) (*IssuerPublicKeys, error)
	predicates                []predicate.IssuerPublicKeys
}

var _ ent.Mutation = (*IssuerPublicKeysMutation)(nil)

// issuerpublickeysOption allows management of the mutation configuration using functional options.
type issuerpublickeysOption func(*IssuerPublicKeysMutation)

// newIssuerPublicKeysMutation creates new mutation for the IssuerPublicKeys entity.
func newIssuerPublicKeysMutation(c config, op Op, opts ...issuerpublickeysOption) *IssuerPublicKeysMutation {
	m := &IssuerPublicKeysMutation{
		config:        c,
		op:            op,
		typ:           TypeIssuerPublicKeys,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIssuerPublicKeysID sets the ID field of the mutation.
func withIssuerPublicKeysID(id string) issuerpublickeysOption {
	return func(m *IssuerPublicKeysMutation) {
		var (
			err   error
			once  sync.Once
			value *IssuerPublicKeys
		)
		m.oldValue = func(ctx context.Context) (*IssuerPublicKeys, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().IssuerPublicKeys.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIssuerPublicKeys sets the old IssuerPublicKeys of the mutation.
func withIssuerPublicKeys(node *IssuerPublicKeys) issuerpublickeysOption {
	return func(m *IssuerPublicKeysMutation) {
		m.oldValue = func(context.Context) (*IssuerPublicKeys, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IssuerPublicKeysMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IssuerPublicKeysMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of IssuerPublicKeys entities.
func (m *IssuerPublicKeysMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IssuerPublicKeysMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IssuerPublicKeysMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().IssuerPublicKeys.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSubjectPublicKeyID sets the "subject_public_key" edge to the SubjectPublicKeys entity by id.
func (m *IssuerPublicKeysMutation) SetSubjectPublicKeyID(id string) {
	m.subject_public_key = &id
}

// ClearSubjectPublicKey clears the "subject_public_key" edge to the SubjectPublicKeys entity.
func (m *IssuerPublicKeysMutation) ClearSubjectPublicKey() {
	m.clearedsubject_public_key = true
}

// SubjectPublicKeyCleared reports if the "subject_public_key" edge to the SubjectPublicKeys entity was cleared.
func (m *IssuerPublicKeysMutation) SubjectPublicKeyCleared() bool {
	return m.clearedsubject_public_key
}

// SubjectPublicKeyID returns the "subject_public_key" edge ID in the mutation.
func (m *IssuerPublicKeysMutation) SubjectPublicKeyID() (id string, exists bool) {
	if m.subject_public_key != nil {
		return *m.subject_public_key, true
	}
	return
}

// SubjectPublicKeyIDs returns the "subject_public_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectPublicKeyID instead. It exists only for internal usage by the builders.
func (m *IssuerPublicKeysMutation) SubjectPublicKeyIDs() (ids []string) {
	if id := m.subject_public_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubjectPublicKey resets all changes to the "subject_public_key" edge.
func (m *IssuerPublicKeysMutation) ResetSubjectPublicKey() {
	m.subject_public_key = nil
	m.clearedsubject_public_key = false
}

// Where appends a list predicates to the IssuerPublicKeysMutation builder.
func (m *IssuerPublicKeysMutation) Where(ps ...predicate.IssuerPublicKeys) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IssuerPublicKeysMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IssuerPublicKeysMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.IssuerPublicKeys, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IssuerPublicKeysMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IssuerPublicKeysMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (IssuerPublicKeys).
func (m *IssuerPublicKeysMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IssuerPublicKeysMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IssuerPublicKeysMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IssuerPublicKeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown IssuerPublicKeys field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuerPublicKeysMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown IssuerPublicKeys field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IssuerPublicKeysMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IssuerPublicKeysMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IssuerPublicKeysMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown IssuerPublicKeys numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IssuerPublicKeysMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IssuerPublicKeysMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IssuerPublicKeysMutation) ClearField(name string) error {
	return fmt.Errorf("unknown IssuerPublicKeys nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IssuerPublicKeysMutation) ResetField(name string) error {
	return fmt.Errorf("unknown IssuerPublicKeys field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IssuerPublicKeysMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subject_public_key != nil {
		edges = append(edges, issuerpublickeys.EdgeSubjectPublicKey)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IssuerPublicKeysMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case issuerpublickeys.EdgeSubjectPublicKey:
		if id := m.subject_public_key; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IssuerPublicKeysMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IssuerPublicKeysMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IssuerPublicKeysMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubject_public_key {
		edges = append(edges, issuerpublickeys.EdgeSubjectPublicKey)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IssuerPublicKeysMutation) EdgeCleared(name string) bool {
	switch name {
	case issuerpublickeys.EdgeSubjectPublicKey:
		return m.clearedsubject_public_key
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IssuerPublicKeysMutation) ClearEdge(name string) error {
	switch name {
	case issuerpublickeys.EdgeSubjectPublicKey:
		m.ClearSubjectPublicKey()
		return nil
	}
	return fmt.Errorf("unknown IssuerPublicKeys unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IssuerPublicKeysMutation) ResetEdge(name string) error {
	switch name {
	case issuerpublickeys.EdgeSubjectPublicKey:
		m.ResetSubjectPublicKey()
		return nil
	}
	return fmt.Errorf("unknown IssuerPublicKeys edge %s", name)
}

// PKCESMutation represents an operation that mutates the PKCES nodes in the graph.
type PKCESMutation struct {
	config
	op                Op
	typ               string
	id                *string
	clearedFields     map[string]struct{}
	request_id        *string
	clearedrequest_id bool
	done              bool
	oldValue          func(context.Context) (*PKCES, error)
	predicates        []predicate.PKCES
}

var _ ent.Mutation = (*PKCESMutation)(nil)

// pkcesOption allows management of the mutation configuration using functional options.
type pkcesOption func(*PKCESMutation)

// newPKCESMutation creates new mutation for the PKCES entity.
func newPKCESMutation(c config, op Op, opts ...pkcesOption) *PKCESMutation {
	m := &PKCESMutation{
		config:        c,
		op:            op,
		typ:           TypePKCES,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPKCESID sets the ID field of the mutation.
func withPKCESID(id string) pkcesOption {
	return func(m *PKCESMutation) {
		var (
			err   error
			once  sync.Once
			value *PKCES
		)
		m.oldValue = func(ctx context.Context) (*PKCES, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PKCES.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPKCES sets the old PKCES of the mutation.
func withPKCES(node *PKCES) pkcesOption {
	return func(m *PKCESMutation) {
		m.oldValue = func(context.Context) (*PKCES, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PKCESMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PKCESMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PKCES entities.
func (m *PKCESMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PKCESMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PKCESMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PKCES.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestIDID sets the "request_id" edge to the Request entity by id.
func (m *PKCESMutation) SetRequestIDID(id string) {
	m.request_id = &id
}

// ClearRequestID clears the "request_id" edge to the Request entity.
func (m *PKCESMutation) ClearRequestID() {
	m.clearedrequest_id = true
}

// RequestIDCleared reports if the "request_id" edge to the Request entity was cleared.
func (m *PKCESMutation) RequestIDCleared() bool {
	return m.clearedrequest_id
}

// RequestIDID returns the "request_id" edge ID in the mutation.
func (m *PKCESMutation) RequestIDID() (id string, exists bool) {
	if m.request_id != nil {
		return *m.request_id, true
	}
	return
}

// RequestIDIDs returns the "request_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestIDID instead. It exists only for internal usage by the builders.
func (m *PKCESMutation) RequestIDIDs() (ids []string) {
	if id := m.request_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestID resets all changes to the "request_id" edge.
func (m *PKCESMutation) ResetRequestID() {
	m.request_id = nil
	m.clearedrequest_id = false
}

// Where appends a list predicates to the PKCESMutation builder.
func (m *PKCESMutation) Where(ps ...predicate.PKCES) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PKCESMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PKCESMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PKCES, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PKCESMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PKCESMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PKCES).
func (m *PKCESMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PKCESMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PKCESMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PKCESMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown PKCES field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PKCESMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PKCES field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PKCESMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PKCESMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PKCESMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown PKCES numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PKCESMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PKCESMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PKCESMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PKCES nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PKCESMutation) ResetField(name string) error {
	return fmt.Errorf("unknown PKCES field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PKCESMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.request_id != nil {
		edges = append(edges, pkces.EdgeRequestID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PKCESMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pkces.EdgeRequestID:
		if id := m.request_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PKCESMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PKCESMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PKCESMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequest_id {
		edges = append(edges, pkces.EdgeRequestID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PKCESMutation) EdgeCleared(name string) bool {
	switch name {
	case pkces.EdgeRequestID:
		return m.clearedrequest_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PKCESMutation) ClearEdge(name string) error {
	switch name {
	case pkces.EdgeRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown PKCES unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PKCESMutation) ResetEdge(name string) error {
	switch name {
	case pkces.EdgeRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown PKCES edge %s", name)
}

// PublicKeyScopesMutation represents an operation that mutates the PublicKeyScopes nodes in the graph.
type PublicKeyScopesMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	json_web_key                 *jose.JSONWebKey
	scopes                       *[]string
	appendscopes                 []string
	clearedFields                map[string]struct{}
	subject_public_key_id        *string
	clearedsubject_public_key_id bool
	done                         bool
	oldValue                     func(context.Context) (*PublicKeyScopes, error)
	predicates                   []predicate.PublicKeyScopes
}

var _ ent.Mutation = (*PublicKeyScopesMutation)(nil)

// publickeyscopesOption allows management of the mutation configuration using functional options.
type publickeyscopesOption func(*PublicKeyScopesMutation)

// newPublicKeyScopesMutation creates new mutation for the PublicKeyScopes entity.
func newPublicKeyScopesMutation(c config, op Op, opts ...publickeyscopesOption) *PublicKeyScopesMutation {
	m := &PublicKeyScopesMutation{
		config:        c,
		op:            op,
		typ:           TypePublicKeyScopes,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPublicKeyScopesID sets the ID field of the mutation.
func withPublicKeyScopesID(id string) publickeyscopesOption {
	return func(m *PublicKeyScopesMutation) {
		var (
			err   error
			once  sync.Once
			value *PublicKeyScopes
		)
		m.oldValue = func(ctx context.Context) (*PublicKeyScopes, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PublicKeyScopes.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPublicKeyScopes sets the old PublicKeyScopes of the mutation.
func withPublicKeyScopes(node *PublicKeyScopes) publickeyscopesOption {
	return func(m *PublicKeyScopesMutation) {
		m.oldValue = func(context.Context) (*PublicKeyScopes, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PublicKeyScopesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PublicKeyScopesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PublicKeyScopes entities.
func (m *PublicKeyScopesMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PublicKeyScopesMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PublicKeyScopesMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PublicKeyScopes.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJSONWebKey sets the "json_web_key" field.
func (m *PublicKeyScopesMutation) SetJSONWebKey(jwk jose.JSONWebKey) {
	m.json_web_key = &jwk
}

// JSONWebKey returns the value of the "json_web_key" field in the mutation.
func (m *PublicKeyScopesMutation) JSONWebKey() (r jose.JSONWebKey, exists bool) {
	v := m.json_web_key
	if v == nil {
		return
	}
	return *v, true
}

// OldJSONWebKey returns the old "json_web_key" field's value of the PublicKeyScopes entity.
// If the PublicKeyScopes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicKeyScopesMutation) OldJSONWebKey(ctx context.Context) (v jose.JSONWebKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJSONWebKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJSONWebKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJSONWebKey: %w", err)
	}
	return oldValue.JSONWebKey, nil
}

// ResetJSONWebKey resets all changes to the "json_web_key" field.
func (m *PublicKeyScopesMutation) ResetJSONWebKey() {
	m.json_web_key = nil
}

// SetScopes sets the "scopes" field.
func (m *PublicKeyScopesMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *PublicKeyScopesMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the PublicKeyScopes entity.
// If the PublicKeyScopes object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PublicKeyScopesMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *PublicKeyScopesMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *PublicKeyScopesMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *PublicKeyScopesMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetSubjectPublicKeyIDID sets the "subject_public_key_id" edge to the SubjectPublicKeys entity by id.
func (m *PublicKeyScopesMutation) SetSubjectPublicKeyIDID(id string) {
	m.subject_public_key_id = &id
}

// ClearSubjectPublicKeyID clears the "subject_public_key_id" edge to the SubjectPublicKeys entity.
func (m *PublicKeyScopesMutation) ClearSubjectPublicKeyID() {
	m.clearedsubject_public_key_id = true
}

// SubjectPublicKeyIDCleared reports if the "subject_public_key_id" edge to the SubjectPublicKeys entity was cleared.
func (m *PublicKeyScopesMutation) SubjectPublicKeyIDCleared() bool {
	return m.clearedsubject_public_key_id
}

// SubjectPublicKeyIDID returns the "subject_public_key_id" edge ID in the mutation.
func (m *PublicKeyScopesMutation) SubjectPublicKeyIDID() (id string, exists bool) {
	if m.subject_public_key_id != nil {
		return *m.subject_public_key_id, true
	}
	return
}

// SubjectPublicKeyIDIDs returns the "subject_public_key_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubjectPublicKeyIDID instead. It exists only for internal usage by the builders.
func (m *PublicKeyScopesMutation) SubjectPublicKeyIDIDs() (ids []string) {
	if id := m.subject_public_key_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubjectPublicKeyID resets all changes to the "subject_public_key_id" edge.
func (m *PublicKeyScopesMutation) ResetSubjectPublicKeyID() {
	m.subject_public_key_id = nil
	m.clearedsubject_public_key_id = false
}

// Where appends a list predicates to the PublicKeyScopesMutation builder.
func (m *PublicKeyScopesMutation) Where(ps ...predicate.PublicKeyScopes) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PublicKeyScopesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PublicKeyScopesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PublicKeyScopes, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PublicKeyScopesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PublicKeyScopesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PublicKeyScopes).
func (m *PublicKeyScopesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PublicKeyScopesMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.json_web_key != nil {
		fields = append(fields, publickeyscopes.FieldJSONWebKey)
	}
	if m.scopes != nil {
		fields = append(fields, publickeyscopes.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PublicKeyScopesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case publickeyscopes.FieldJSONWebKey:
		return m.JSONWebKey()
	case publickeyscopes.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PublicKeyScopesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case publickeyscopes.FieldJSONWebKey:
		return m.OldJSONWebKey(ctx)
	case publickeyscopes.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown PublicKeyScopes field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicKeyScopesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case publickeyscopes.FieldJSONWebKey:
		v, ok := value.(jose.JSONWebKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJSONWebKey(v)
		return nil
	case publickeyscopes.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown PublicKeyScopes field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PublicKeyScopesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PublicKeyScopesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PublicKeyScopesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PublicKeyScopes numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PublicKeyScopesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PublicKeyScopesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PublicKeyScopesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PublicKeyScopes nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PublicKeyScopesMutation) ResetField(name string) error {
	switch name {
	case publickeyscopes.FieldJSONWebKey:
		m.ResetJSONWebKey()
		return nil
	case publickeyscopes.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown PublicKeyScopes field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PublicKeyScopesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.subject_public_key_id != nil {
		edges = append(edges, publickeyscopes.EdgeSubjectPublicKeyID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PublicKeyScopesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case publickeyscopes.EdgeSubjectPublicKeyID:
		if id := m.subject_public_key_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PublicKeyScopesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PublicKeyScopesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PublicKeyScopesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsubject_public_key_id {
		edges = append(edges, publickeyscopes.EdgeSubjectPublicKeyID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PublicKeyScopesMutation) EdgeCleared(name string) bool {
	switch name {
	case publickeyscopes.EdgeSubjectPublicKeyID:
		return m.clearedsubject_public_key_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PublicKeyScopesMutation) ClearEdge(name string) error {
	switch name {
	case publickeyscopes.EdgeSubjectPublicKeyID:
		m.ClearSubjectPublicKeyID()
		return nil
	}
	return fmt.Errorf("unknown PublicKeyScopes unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PublicKeyScopesMutation) ResetEdge(name string) error {
	switch name {
	case publickeyscopes.EdgeSubjectPublicKeyID:
		m.ResetSubjectPublicKeyID()
		return nil
	}
	return fmt.Errorf("unknown PublicKeyScopes edge %s", name)
}

// RefreshTokensMutation represents an operation that mutates the RefreshTokens nodes in the graph.
type RefreshTokensMutation struct {
	config
	op                Op
	typ               string
	id                *string
	active            *bool
	clearedFields     map[string]struct{}
	request_id        *string
	clearedrequest_id bool
	done              bool
	oldValue          func(context.Context) (*RefreshTokens, error)
	predicates        []predicate.RefreshTokens
}

var _ ent.Mutation = (*RefreshTokensMutation)(nil)

// refreshtokensOption allows management of the mutation configuration using functional options.
type refreshtokensOption func(*RefreshTokensMutation)

// newRefreshTokensMutation creates new mutation for the RefreshTokens entity.
func newRefreshTokensMutation(c config, op Op, opts ...refreshtokensOption) *RefreshTokensMutation {
	m := &RefreshTokensMutation{
		config:        c,
		op:            op,
		typ:           TypeRefreshTokens,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefreshTokensID sets the ID field of the mutation.
func withRefreshTokensID(id string) refreshtokensOption {
	return func(m *RefreshTokensMutation) {
		var (
			err   error
			once  sync.Once
			value *RefreshTokens
		)
		m.oldValue = func(ctx context.Context) (*RefreshTokens, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RefreshTokens.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefreshTokens sets the old RefreshTokens of the mutation.
func withRefreshTokens(node *RefreshTokens) refreshtokensOption {
	return func(m *RefreshTokensMutation) {
		m.oldValue = func(context.Context) (*RefreshTokens, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefreshTokensMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefreshTokensMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RefreshTokens entities.
func (m *RefreshTokensMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefreshTokensMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefreshTokensMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RefreshTokens.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActive sets the "active" field.
func (m *RefreshTokensMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *RefreshTokensMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the RefreshTokens entity.
// If the RefreshTokens object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefreshTokensMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *RefreshTokensMutation) ResetActive() {
	m.active = nil
}

// SetRequestIDID sets the "request_id" edge to the Request entity by id.
func (m *RefreshTokensMutation) SetRequestIDID(id string) {
	m.request_id = &id
}

// ClearRequestID clears the "request_id" edge to the Request entity.
func (m *RefreshTokensMutation) ClearRequestID() {
	m.clearedrequest_id = true
}

// RequestIDCleared reports if the "request_id" edge to the Request entity was cleared.
func (m *RefreshTokensMutation) RequestIDCleared() bool {
	return m.clearedrequest_id
}

// RequestIDID returns the "request_id" edge ID in the mutation.
func (m *RefreshTokensMutation) RequestIDID() (id string, exists bool) {
	if m.request_id != nil {
		return *m.request_id, true
	}
	return
}

// RequestIDIDs returns the "request_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestIDID instead. It exists only for internal usage by the builders.
func (m *RefreshTokensMutation) RequestIDIDs() (ids []string) {
	if id := m.request_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestID resets all changes to the "request_id" edge.
func (m *RefreshTokensMutation) ResetRequestID() {
	m.request_id = nil
	m.clearedrequest_id = false
}

// Where appends a list predicates to the RefreshTokensMutation builder.
func (m *RefreshTokensMutation) Where(ps ...predicate.RefreshTokens) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RefreshTokensMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RefreshTokensMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RefreshTokens, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RefreshTokensMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RefreshTokensMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RefreshTokens).
func (m *RefreshTokensMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefreshTokensMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.active != nil {
		fields = append(fields, refreshtokens.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefreshTokensMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refreshtokens.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefreshTokensMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refreshtokens.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown RefreshTokens field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokensMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refreshtokens.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown RefreshTokens field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefreshTokensMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefreshTokensMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefreshTokensMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RefreshTokens numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefreshTokensMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefreshTokensMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefreshTokensMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RefreshTokens nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefreshTokensMutation) ResetField(name string) error {
	switch name {
	case refreshtokens.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown RefreshTokens field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefreshTokensMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.request_id != nil {
		edges = append(edges, refreshtokens.EdgeRequestID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefreshTokensMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case refreshtokens.EdgeRequestID:
		if id := m.request_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefreshTokensMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefreshTokensMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefreshTokensMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequest_id {
		edges = append(edges, refreshtokens.EdgeRequestID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefreshTokensMutation) EdgeCleared(name string) bool {
	switch name {
	case refreshtokens.EdgeRequestID:
		return m.clearedrequest_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefreshTokensMutation) ClearEdge(name string) error {
	switch name {
	case refreshtokens.EdgeRequestID:
		m.ClearRequestID()
		return nil
	}
	return fmt.Errorf("unknown RefreshTokens unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefreshTokensMutation) ResetEdge(name string) error {
	switch name {
	case refreshtokens.EdgeRequestID:
		m.ResetRequestID()
		return nil
	}
	return fmt.Errorf("unknown RefreshTokens edge %s", name)
}

// RequestMutation represents an operation that mutates the Request nodes in the graph.
type RequestMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	requestedAt              *time.Time
	scopes                   *[]string
	appendscopes             []string
	granted_scopes           *[]string
	appendgranted_scopes     []string
	requested_audience       *[]string
	appendrequested_audience []string
	granted_audience         *[]string
	appendgranted_audience   []string
	form                     *url.Values
	lang                     *language.Tag
	clearedFields            map[string]struct{}
	client_id                *string
	clearedclient_id         bool
	session_id               *string
	clearedsession_id        bool
	refresh_token            *string
	clearedrefresh_token     bool
	authorize_code           *string
	clearedauthorize_code    bool
	access_token             *string
	clearedaccess_token      bool
	id_session               *string
	clearedid_session        bool
	pkce                     *string
	clearedpkce              bool
	done                     bool
	oldValue                 func(context.Context) (*Request, error)
	predicates               []predicate.Request
}

var _ ent.Mutation = (*RequestMutation)(nil)

// requestOption allows management of the mutation configuration using functional options.
type requestOption func(*RequestMutation)

// newRequestMutation creates new mutation for the Request entity.
func newRequestMutation(c config, op Op, opts ...requestOption) *RequestMutation {
	m := &RequestMutation{
		config:        c,
		op:            op,
		typ:           TypeRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRequestID sets the ID field of the mutation.
func withRequestID(id string) requestOption {
	return func(m *RequestMutation) {
		var (
			err   error
			once  sync.Once
			value *Request
		)
		m.oldValue = func(ctx context.Context) (*Request, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Request.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRequest sets the old Request of the mutation.
func withRequest(node *Request) requestOption {
	return func(m *RequestMutation) {
		m.oldValue = func(context.Context) (*Request, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Request entities.
func (m *RequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Request.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRequestedAt sets the "requestedAt" field.
func (m *RequestMutation) SetRequestedAt(t time.Time) {
	m.requestedAt = &t
}

// RequestedAt returns the value of the "requestedAt" field in the mutation.
func (m *RequestMutation) RequestedAt() (r time.Time, exists bool) {
	v := m.requestedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAt returns the old "requestedAt" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAt: %w", err)
	}
	return oldValue.RequestedAt, nil
}

// ResetRequestedAt resets all changes to the "requestedAt" field.
func (m *RequestMutation) ResetRequestedAt() {
	m.requestedAt = nil
}

// SetScopes sets the "scopes" field.
func (m *RequestMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *RequestMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *RequestMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *RequestMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *RequestMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetGrantedScopes sets the "granted_scopes" field.
func (m *RequestMutation) SetGrantedScopes(s []string) {
	m.granted_scopes = &s
	m.appendgranted_scopes = nil
}

// GrantedScopes returns the value of the "granted_scopes" field in the mutation.
func (m *RequestMutation) GrantedScopes() (r []string, exists bool) {
	v := m.granted_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedScopes returns the old "granted_scopes" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldGrantedScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedScopes: %w", err)
	}
	return oldValue.GrantedScopes, nil
}

// AppendGrantedScopes adds s to the "granted_scopes" field.
func (m *RequestMutation) AppendGrantedScopes(s []string) {
	m.appendgranted_scopes = append(m.appendgranted_scopes, s...)
}

// AppendedGrantedScopes returns the list of values that were appended to the "granted_scopes" field in this mutation.
func (m *RequestMutation) AppendedGrantedScopes() ([]string, bool) {
	if len(m.appendgranted_scopes) == 0 {
		return nil, false
	}
	return m.appendgranted_scopes, true
}

// ResetGrantedScopes resets all changes to the "granted_scopes" field.
func (m *RequestMutation) ResetGrantedScopes() {
	m.granted_scopes = nil
	m.appendgranted_scopes = nil
}

// SetRequestedAudience sets the "requested_audience" field.
func (m *RequestMutation) SetRequestedAudience(s []string) {
	m.requested_audience = &s
	m.appendrequested_audience = nil
}

// RequestedAudience returns the value of the "requested_audience" field in the mutation.
func (m *RequestMutation) RequestedAudience() (r []string, exists bool) {
	v := m.requested_audience
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestedAudience returns the old "requested_audience" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldRequestedAudience(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestedAudience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestedAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestedAudience: %w", err)
	}
	return oldValue.RequestedAudience, nil
}

// AppendRequestedAudience adds s to the "requested_audience" field.
func (m *RequestMutation) AppendRequestedAudience(s []string) {
	m.appendrequested_audience = append(m.appendrequested_audience, s...)
}

// AppendedRequestedAudience returns the list of values that were appended to the "requested_audience" field in this mutation.
func (m *RequestMutation) AppendedRequestedAudience() ([]string, bool) {
	if len(m.appendrequested_audience) == 0 {
		return nil, false
	}
	return m.appendrequested_audience, true
}

// ResetRequestedAudience resets all changes to the "requested_audience" field.
func (m *RequestMutation) ResetRequestedAudience() {
	m.requested_audience = nil
	m.appendrequested_audience = nil
}

// SetGrantedAudience sets the "granted_audience" field.
func (m *RequestMutation) SetGrantedAudience(s []string) {
	m.granted_audience = &s
	m.appendgranted_audience = nil
}

// GrantedAudience returns the value of the "granted_audience" field in the mutation.
func (m *RequestMutation) GrantedAudience() (r []string, exists bool) {
	v := m.granted_audience
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedAudience returns the old "granted_audience" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldGrantedAudience(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedAudience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedAudience: %w", err)
	}
	return oldValue.GrantedAudience, nil
}

// AppendGrantedAudience adds s to the "granted_audience" field.
func (m *RequestMutation) AppendGrantedAudience(s []string) {
	m.appendgranted_audience = append(m.appendgranted_audience, s...)
}

// AppendedGrantedAudience returns the list of values that were appended to the "granted_audience" field in this mutation.
func (m *RequestMutation) AppendedGrantedAudience() ([]string, bool) {
	if len(m.appendgranted_audience) == 0 {
		return nil, false
	}
	return m.appendgranted_audience, true
}

// ResetGrantedAudience resets all changes to the "granted_audience" field.
func (m *RequestMutation) ResetGrantedAudience() {
	m.granted_audience = nil
	m.appendgranted_audience = nil
}

// SetForm sets the "form" field.
func (m *RequestMutation) SetForm(u url.Values) {
	m.form = &u
}

// Form returns the value of the "form" field in the mutation.
func (m *RequestMutation) Form() (r url.Values, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldForm(ctx context.Context) (v url.Values, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ResetForm resets all changes to the "form" field.
func (m *RequestMutation) ResetForm() {
	m.form = nil
}

// SetLang sets the "lang" field.
func (m *RequestMutation) SetLang(l language.Tag) {
	m.lang = &l
}

// Lang returns the value of the "lang" field in the mutation.
func (m *RequestMutation) Lang() (r language.Tag, exists bool) {
	v := m.lang
	if v == nil {
		return
	}
	return *v, true
}

// OldLang returns the old "lang" field's value of the Request entity.
// If the Request object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RequestMutation) OldLang(ctx context.Context) (v language.Tag, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLang is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLang requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLang: %w", err)
	}
	return oldValue.Lang, nil
}

// ClearLang clears the value of the "lang" field.
func (m *RequestMutation) ClearLang() {
	m.lang = nil
	m.clearedFields[request.FieldLang] = struct{}{}
}

// LangCleared returns if the "lang" field was cleared in this mutation.
func (m *RequestMutation) LangCleared() bool {
	_, ok := m.clearedFields[request.FieldLang]
	return ok
}

// ResetLang resets all changes to the "lang" field.
func (m *RequestMutation) ResetLang() {
	m.lang = nil
	delete(m.clearedFields, request.FieldLang)
}

// SetClientIDID sets the "client_id" edge to the Clients entity by id.
func (m *RequestMutation) SetClientIDID(id string) {
	m.client_id = &id
}

// ClearClientID clears the "client_id" edge to the Clients entity.
func (m *RequestMutation) ClearClientID() {
	m.clearedclient_id = true
}

// ClientIDCleared reports if the "client_id" edge to the Clients entity was cleared.
func (m *RequestMutation) ClientIDCleared() bool {
	return m.clearedclient_id
}

// ClientIDID returns the "client_id" edge ID in the mutation.
func (m *RequestMutation) ClientIDID() (id string, exists bool) {
	if m.client_id != nil {
		return *m.client_id, true
	}
	return
}

// ClientIDIDs returns the "client_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClientIDID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) ClientIDIDs() (ids []string) {
	if id := m.client_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClientID resets all changes to the "client_id" edge.
func (m *RequestMutation) ResetClientID() {
	m.client_id = nil
	m.clearedclient_id = false
}

// SetSessionIDID sets the "session_id" edge to the Session entity by id.
func (m *RequestMutation) SetSessionIDID(id string) {
	m.session_id = &id
}

// ClearSessionID clears the "session_id" edge to the Session entity.
func (m *RequestMutation) ClearSessionID() {
	m.clearedsession_id = true
}

// SessionIDCleared reports if the "session_id" edge to the Session entity was cleared.
func (m *RequestMutation) SessionIDCleared() bool {
	return m.clearedsession_id
}

// SessionIDID returns the "session_id" edge ID in the mutation.
func (m *RequestMutation) SessionIDID() (id string, exists bool) {
	if m.session_id != nil {
		return *m.session_id, true
	}
	return
}

// SessionIDIDs returns the "session_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionIDID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) SessionIDIDs() (ids []string) {
	if id := m.session_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSessionID resets all changes to the "session_id" edge.
func (m *RequestMutation) ResetSessionID() {
	m.session_id = nil
	m.clearedsession_id = false
}

// SetRefreshTokenID sets the "refresh_token" edge to the RefreshTokens entity by id.
func (m *RequestMutation) SetRefreshTokenID(id string) {
	m.refresh_token = &id
}

// ClearRefreshToken clears the "refresh_token" edge to the RefreshTokens entity.
func (m *RequestMutation) ClearRefreshToken() {
	m.clearedrefresh_token = true
}

// RefreshTokenCleared reports if the "refresh_token" edge to the RefreshTokens entity was cleared.
func (m *RequestMutation) RefreshTokenCleared() bool {
	return m.clearedrefresh_token
}

// RefreshTokenID returns the "refresh_token" edge ID in the mutation.
func (m *RequestMutation) RefreshTokenID() (id string, exists bool) {
	if m.refresh_token != nil {
		return *m.refresh_token, true
	}
	return
}

// RefreshTokenIDs returns the "refresh_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RefreshTokenID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) RefreshTokenIDs() (ids []string) {
	if id := m.refresh_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRefreshToken resets all changes to the "refresh_token" edge.
func (m *RequestMutation) ResetRefreshToken() {
	m.refresh_token = nil
	m.clearedrefresh_token = false
}

// SetAuthorizeCodeID sets the "authorize_code" edge to the AuthorizeCodes entity by id.
func (m *RequestMutation) SetAuthorizeCodeID(id string) {
	m.authorize_code = &id
}

// ClearAuthorizeCode clears the "authorize_code" edge to the AuthorizeCodes entity.
func (m *RequestMutation) ClearAuthorizeCode() {
	m.clearedauthorize_code = true
}

// AuthorizeCodeCleared reports if the "authorize_code" edge to the AuthorizeCodes entity was cleared.
func (m *RequestMutation) AuthorizeCodeCleared() bool {
	return m.clearedauthorize_code
}

// AuthorizeCodeID returns the "authorize_code" edge ID in the mutation.
func (m *RequestMutation) AuthorizeCodeID() (id string, exists bool) {
	if m.authorize_code != nil {
		return *m.authorize_code, true
	}
	return
}

// AuthorizeCodeIDs returns the "authorize_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorizeCodeID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) AuthorizeCodeIDs() (ids []string) {
	if id := m.authorize_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthorizeCode resets all changes to the "authorize_code" edge.
func (m *RequestMutation) ResetAuthorizeCode() {
	m.authorize_code = nil
	m.clearedauthorize_code = false
}

// SetAccessTokenID sets the "access_token" edge to the AccessTokens entity by id.
func (m *RequestMutation) SetAccessTokenID(id string) {
	m.access_token = &id
}

// ClearAccessToken clears the "access_token" edge to the AccessTokens entity.
func (m *RequestMutation) ClearAccessToken() {
	m.clearedaccess_token = true
}

// AccessTokenCleared reports if the "access_token" edge to the AccessTokens entity was cleared.
func (m *RequestMutation) AccessTokenCleared() bool {
	return m.clearedaccess_token
}

// AccessTokenID returns the "access_token" edge ID in the mutation.
func (m *RequestMutation) AccessTokenID() (id string, exists bool) {
	if m.access_token != nil {
		return *m.access_token, true
	}
	return
}

// AccessTokenIDs returns the "access_token" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessTokenID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) AccessTokenIDs() (ids []string) {
	if id := m.access_token; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessToken resets all changes to the "access_token" edge.
func (m *RequestMutation) ResetAccessToken() {
	m.access_token = nil
	m.clearedaccess_token = false
}

// SetIDSessionID sets the "id_session" edge to the IDSessions entity by id.
func (m *RequestMutation) SetIDSessionID(id string) {
	m.id_session = &id
}

// ClearIDSession clears the "id_session" edge to the IDSessions entity.
func (m *RequestMutation) ClearIDSession() {
	m.clearedid_session = true
}

// IDSessionCleared reports if the "id_session" edge to the IDSessions entity was cleared.
func (m *RequestMutation) IDSessionCleared() bool {
	return m.clearedid_session
}

// IDSessionID returns the "id_session" edge ID in the mutation.
func (m *RequestMutation) IDSessionID() (id string, exists bool) {
	if m.id_session != nil {
		return *m.id_session, true
	}
	return
}

// IDSessionIDs returns the "id_session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IDSessionID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) IDSessionIDs() (ids []string) {
	if id := m.id_session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIDSession resets all changes to the "id_session" edge.
func (m *RequestMutation) ResetIDSession() {
	m.id_session = nil
	m.clearedid_session = false
}

// SetPkceID sets the "pkce" edge to the PKCES entity by id.
func (m *RequestMutation) SetPkceID(id string) {
	m.pkce = &id
}

// ClearPkce clears the "pkce" edge to the PKCES entity.
func (m *RequestMutation) ClearPkce() {
	m.clearedpkce = true
}

// PkceCleared reports if the "pkce" edge to the PKCES entity was cleared.
func (m *RequestMutation) PkceCleared() bool {
	return m.clearedpkce
}

// PkceID returns the "pkce" edge ID in the mutation.
func (m *RequestMutation) PkceID() (id string, exists bool) {
	if m.pkce != nil {
		return *m.pkce, true
	}
	return
}

// PkceIDs returns the "pkce" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PkceID instead. It exists only for internal usage by the builders.
func (m *RequestMutation) PkceIDs() (ids []string) {
	if id := m.pkce; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPkce resets all changes to the "pkce" edge.
func (m *RequestMutation) ResetPkce() {
	m.pkce = nil
	m.clearedpkce = false
}

// Where appends a list predicates to the RequestMutation builder.
func (m *RequestMutation) Where(ps ...predicate.Request) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Request, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Request).
func (m *RequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RequestMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.requestedAt != nil {
		fields = append(fields, request.FieldRequestedAt)
	}
	if m.scopes != nil {
		fields = append(fields, request.FieldScopes)
	}
	if m.granted_scopes != nil {
		fields = append(fields, request.FieldGrantedScopes)
	}
	if m.requested_audience != nil {
		fields = append(fields, request.FieldRequestedAudience)
	}
	if m.granted_audience != nil {
		fields = append(fields, request.FieldGrantedAudience)
	}
	if m.form != nil {
		fields = append(fields, request.FieldForm)
	}
	if m.lang != nil {
		fields = append(fields, request.FieldLang)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case request.FieldRequestedAt:
		return m.RequestedAt()
	case request.FieldScopes:
		return m.Scopes()
	case request.FieldGrantedScopes:
		return m.GrantedScopes()
	case request.FieldRequestedAudience:
		return m.RequestedAudience()
	case request.FieldGrantedAudience:
		return m.GrantedAudience()
	case request.FieldForm:
		return m.Form()
	case request.FieldLang:
		return m.Lang()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case request.FieldRequestedAt:
		return m.OldRequestedAt(ctx)
	case request.FieldScopes:
		return m.OldScopes(ctx)
	case request.FieldGrantedScopes:
		return m.OldGrantedScopes(ctx)
	case request.FieldRequestedAudience:
		return m.OldRequestedAudience(ctx)
	case request.FieldGrantedAudience:
		return m.OldGrantedAudience(ctx)
	case request.FieldForm:
		return m.OldForm(ctx)
	case request.FieldLang:
		return m.OldLang(ctx)
	}
	return nil, fmt.Errorf("unknown Request field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case request.FieldRequestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAt(v)
		return nil
	case request.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case request.FieldGrantedScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedScopes(v)
		return nil
	case request.FieldRequestedAudience:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestedAudience(v)
		return nil
	case request.FieldGrantedAudience:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedAudience(v)
		return nil
	case request.FieldForm:
		v, ok := value.(url.Values)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case request.FieldLang:
		v, ok := value.(language.Tag)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLang(v)
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Request numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(request.FieldLang) {
		fields = append(fields, request.FieldLang)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RequestMutation) ClearField(name string) error {
	switch name {
	case request.FieldLang:
		m.ClearLang()
		return nil
	}
	return fmt.Errorf("unknown Request nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RequestMutation) ResetField(name string) error {
	switch name {
	case request.FieldRequestedAt:
		m.ResetRequestedAt()
		return nil
	case request.FieldScopes:
		m.ResetScopes()
		return nil
	case request.FieldGrantedScopes:
		m.ResetGrantedScopes()
		return nil
	case request.FieldRequestedAudience:
		m.ResetRequestedAudience()
		return nil
	case request.FieldGrantedAudience:
		m.ResetGrantedAudience()
		return nil
	case request.FieldForm:
		m.ResetForm()
		return nil
	case request.FieldLang:
		m.ResetLang()
		return nil
	}
	return fmt.Errorf("unknown Request field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.client_id != nil {
		edges = append(edges, request.EdgeClientID)
	}
	if m.session_id != nil {
		edges = append(edges, request.EdgeSessionID)
	}
	if m.refresh_token != nil {
		edges = append(edges, request.EdgeRefreshToken)
	}
	if m.authorize_code != nil {
		edges = append(edges, request.EdgeAuthorizeCode)
	}
	if m.access_token != nil {
		edges = append(edges, request.EdgeAccessToken)
	}
	if m.id_session != nil {
		edges = append(edges, request.EdgeIDSession)
	}
	if m.pkce != nil {
		edges = append(edges, request.EdgePkce)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case request.EdgeClientID:
		if id := m.client_id; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeSessionID:
		if id := m.session_id; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeRefreshToken:
		if id := m.refresh_token; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeAuthorizeCode:
		if id := m.authorize_code; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeAccessToken:
		if id := m.access_token; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgeIDSession:
		if id := m.id_session; id != nil {
			return []ent.Value{*id}
		}
	case request.EdgePkce:
		if id := m.pkce; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedclient_id {
		edges = append(edges, request.EdgeClientID)
	}
	if m.clearedsession_id {
		edges = append(edges, request.EdgeSessionID)
	}
	if m.clearedrefresh_token {
		edges = append(edges, request.EdgeRefreshToken)
	}
	if m.clearedauthorize_code {
		edges = append(edges, request.EdgeAuthorizeCode)
	}
	if m.clearedaccess_token {
		edges = append(edges, request.EdgeAccessToken)
	}
	if m.clearedid_session {
		edges = append(edges, request.EdgeIDSession)
	}
	if m.clearedpkce {
		edges = append(edges, request.EdgePkce)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RequestMutation) EdgeCleared(name string) bool {
	switch name {
	case request.EdgeClientID:
		return m.clearedclient_id
	case request.EdgeSessionID:
		return m.clearedsession_id
	case request.EdgeRefreshToken:
		return m.clearedrefresh_token
	case request.EdgeAuthorizeCode:
		return m.clearedauthorize_code
	case request.EdgeAccessToken:
		return m.clearedaccess_token
	case request.EdgeIDSession:
		return m.clearedid_session
	case request.EdgePkce:
		return m.clearedpkce
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RequestMutation) ClearEdge(name string) error {
	switch name {
	case request.EdgeClientID:
		m.ClearClientID()
		return nil
	case request.EdgeSessionID:
		m.ClearSessionID()
		return nil
	case request.EdgeRefreshToken:
		m.ClearRefreshToken()
		return nil
	case request.EdgeAuthorizeCode:
		m.ClearAuthorizeCode()
		return nil
	case request.EdgeAccessToken:
		m.ClearAccessToken()
		return nil
	case request.EdgeIDSession:
		m.ClearIDSession()
		return nil
	case request.EdgePkce:
		m.ClearPkce()
		return nil
	}
	return fmt.Errorf("unknown Request unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RequestMutation) ResetEdge(name string) error {
	switch name {
	case request.EdgeClientID:
		m.ResetClientID()
		return nil
	case request.EdgeSessionID:
		m.ResetSessionID()
		return nil
	case request.EdgeRefreshToken:
		m.ResetRefreshToken()
		return nil
	case request.EdgeAuthorizeCode:
		m.ResetAuthorizeCode()
		return nil
	case request.EdgeAccessToken:
		m.ResetAccessToken()
		return nil
	case request.EdgeIDSession:
		m.ResetIDSession()
		return nil
	case request.EdgePkce:
		m.ResetPkce()
		return nil
	}
	return fmt.Errorf("unknown Request edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op              Op
	typ             string
	id              *string
	expires_at      *map[string]time.Time
	username        *string
	subject         *string
	extra           *map[string]interface{}
	clearedFields   map[string]struct{}
	requests        map[string]struct{}
	removedrequests map[string]struct{}
	clearedrequests bool
	done            bool
	oldValue        func(context.Context) (*Session, error)
	predicates      []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(value map[string]time.Time) {
	m.expires_at = &value
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r map[string]time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v map[string]time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUsername sets the "username" field.
func (m *SessionMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *SessionMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *SessionMutation) ResetUsername() {
	m.username = nil
}

// SetSubject sets the "subject" field.
func (m *SessionMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *SessionMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *SessionMutation) ResetSubject() {
	m.subject = nil
}

// SetExtra sets the "extra" field.
func (m *SessionMutation) SetExtra(value map[string]interface{}) {
	m.extra = &value
}

// Extra returns the value of the "extra" field in the mutation.
func (m *SessionMutation) Extra() (r map[string]interface{}, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExtra(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ClearExtra clears the value of the "extra" field.
func (m *SessionMutation) ClearExtra() {
	m.extra = nil
	m.clearedFields[session.FieldExtra] = struct{}{}
}

// ExtraCleared returns if the "extra" field was cleared in this mutation.
func (m *SessionMutation) ExtraCleared() bool {
	_, ok := m.clearedFields[session.FieldExtra]
	return ok
}

// ResetExtra resets all changes to the "extra" field.
func (m *SessionMutation) ResetExtra() {
	m.extra = nil
	delete(m.clearedFields, session.FieldExtra)
}

// AddRequestIDs adds the "requests" edge to the Request entity by ids.
func (m *SessionMutation) AddRequestIDs(ids ...string) {
	if m.requests == nil {
		m.requests = make(map[string]struct{})
	}
	for i := range ids {
		m.requests[ids[i]] = struct{}{}
	}
}

// ClearRequests clears the "requests" edge to the Request entity.
func (m *SessionMutation) ClearRequests() {
	m.clearedrequests = true
}

// RequestsCleared reports if the "requests" edge to the Request entity was cleared.
func (m *SessionMutation) RequestsCleared() bool {
	return m.clearedrequests
}

// RemoveRequestIDs removes the "requests" edge to the Request entity by IDs.
func (m *SessionMutation) RemoveRequestIDs(ids ...string) {
	if m.removedrequests == nil {
		m.removedrequests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.requests, ids[i])
		m.removedrequests[ids[i]] = struct{}{}
	}
}

// RemovedRequests returns the removed IDs of the "requests" edge to the Request entity.
func (m *SessionMutation) RemovedRequestsIDs() (ids []string) {
	for id := range m.removedrequests {
		ids = append(ids, id)
	}
	return
}

// RequestsIDs returns the "requests" edge IDs in the mutation.
func (m *SessionMutation) RequestsIDs() (ids []string) {
	for id := range m.requests {
		ids = append(ids, id)
	}
	return
}

// ResetRequests resets all changes to the "requests" edge.
func (m *SessionMutation) ResetRequests() {
	m.requests = nil
	m.clearedrequests = false
	m.removedrequests = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.username != nil {
		fields = append(fields, session.FieldUsername)
	}
	if m.subject != nil {
		fields = append(fields, session.FieldSubject)
	}
	if m.extra != nil {
		fields = append(fields, session.FieldExtra)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldUsername:
		return m.Username()
	case session.FieldSubject:
		return m.Subject()
	case session.FieldExtra:
		return m.Extra()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldUsername:
		return m.OldUsername(ctx)
	case session.FieldSubject:
		return m.OldSubject(ctx)
	case session.FieldExtra:
		return m.OldExtra(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldExpiresAt:
		v, ok := value.(map[string]time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case session.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case session.FieldExtra:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldExtra) {
		fields = append(fields, session.FieldExtra)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldExtra:
		m.ClearExtra()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldUsername:
		m.ResetUsername()
		return nil
	case session.FieldSubject:
		m.ResetSubject()
		return nil
	case session.FieldExtra:
		m.ResetExtra()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.requests != nil {
		edges = append(edges, session.EdgeRequests)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.requests))
		for id := range m.requests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrequests != nil {
		edges = append(edges, session.EdgeRequests)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeRequests:
		ids := make([]ent.Value, 0, len(m.removedrequests))
		for id := range m.removedrequests {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrequests {
		edges = append(edges, session.EdgeRequests)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeRequests:
		return m.clearedrequests
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeRequests:
		m.ResetRequests()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SubjectPublicKeysMutation represents an operation that mutates the SubjectPublicKeys nodes in the graph.
type SubjectPublicKeysMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	clearedFields               map[string]struct{}
	public_key_scope            *string
	clearedpublic_key_scope     bool
	issuer_public_key_id        *string
	clearedissuer_public_key_id bool
	done                        bool
	oldValue                    func(context.Context) (*SubjectPublicKeys, error)
	predicates                  []predicate.SubjectPublicKeys
}

var _ ent.Mutation = (*SubjectPublicKeysMutation)(nil)

// subjectpublickeysOption allows management of the mutation configuration using functional options.
type subjectpublickeysOption func(*SubjectPublicKeysMutation)

// newSubjectPublicKeysMutation creates new mutation for the SubjectPublicKeys entity.
func newSubjectPublicKeysMutation(c config, op Op, opts ...subjectpublickeysOption) *SubjectPublicKeysMutation {
	m := &SubjectPublicKeysMutation{
		config:        c,
		op:            op,
		typ:           TypeSubjectPublicKeys,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubjectPublicKeysID sets the ID field of the mutation.
func withSubjectPublicKeysID(id string) subjectpublickeysOption {
	return func(m *SubjectPublicKeysMutation) {
		var (
			err   error
			once  sync.Once
			value *SubjectPublicKeys
		)
		m.oldValue = func(ctx context.Context) (*SubjectPublicKeys, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubjectPublicKeys.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubjectPublicKeys sets the old SubjectPublicKeys of the mutation.
func withSubjectPublicKeys(node *SubjectPublicKeys) subjectpublickeysOption {
	return func(m *SubjectPublicKeysMutation) {
		m.oldValue = func(context.Context) (*SubjectPublicKeys, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubjectPublicKeysMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubjectPublicKeysMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SubjectPublicKeys entities.
func (m *SubjectPublicKeysMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubjectPublicKeysMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubjectPublicKeysMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubjectPublicKeys.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicKeyScopeID sets the "public_key_scope" edge to the PublicKeyScopes entity by id.
func (m *SubjectPublicKeysMutation) SetPublicKeyScopeID(id string) {
	m.public_key_scope = &id
}

// ClearPublicKeyScope clears the "public_key_scope" edge to the PublicKeyScopes entity.
func (m *SubjectPublicKeysMutation) ClearPublicKeyScope() {
	m.clearedpublic_key_scope = true
}

// PublicKeyScopeCleared reports if the "public_key_scope" edge to the PublicKeyScopes entity was cleared.
func (m *SubjectPublicKeysMutation) PublicKeyScopeCleared() bool {
	return m.clearedpublic_key_scope
}

// PublicKeyScopeID returns the "public_key_scope" edge ID in the mutation.
func (m *SubjectPublicKeysMutation) PublicKeyScopeID() (id string, exists bool) {
	if m.public_key_scope != nil {
		return *m.public_key_scope, true
	}
	return
}

// PublicKeyScopeIDs returns the "public_key_scope" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PublicKeyScopeID instead. It exists only for internal usage by the builders.
func (m *SubjectPublicKeysMutation) PublicKeyScopeIDs() (ids []string) {
	if id := m.public_key_scope; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPublicKeyScope resets all changes to the "public_key_scope" edge.
func (m *SubjectPublicKeysMutation) ResetPublicKeyScope() {
	m.public_key_scope = nil
	m.clearedpublic_key_scope = false
}

// SetIssuerPublicKeyIDID sets the "issuer_public_key_id" edge to the IssuerPublicKeys entity by id.
func (m *SubjectPublicKeysMutation) SetIssuerPublicKeyIDID(id string) {
	m.issuer_public_key_id = &id
}

// ClearIssuerPublicKeyID clears the "issuer_public_key_id" edge to the IssuerPublicKeys entity.
func (m *SubjectPublicKeysMutation) ClearIssuerPublicKeyID() {
	m.clearedissuer_public_key_id = true
}

// IssuerPublicKeyIDCleared reports if the "issuer_public_key_id" edge to the IssuerPublicKeys entity was cleared.
func (m *SubjectPublicKeysMutation) IssuerPublicKeyIDCleared() bool {
	return m.clearedissuer_public_key_id
}

// IssuerPublicKeyIDID returns the "issuer_public_key_id" edge ID in the mutation.
func (m *SubjectPublicKeysMutation) IssuerPublicKeyIDID() (id string, exists bool) {
	if m.issuer_public_key_id != nil {
		return *m.issuer_public_key_id, true
	}
	return
}

// IssuerPublicKeyIDIDs returns the "issuer_public_key_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuerPublicKeyIDID instead. It exists only for internal usage by the builders.
func (m *SubjectPublicKeysMutation) IssuerPublicKeyIDIDs() (ids []string) {
	if id := m.issuer_public_key_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuerPublicKeyID resets all changes to the "issuer_public_key_id" edge.
func (m *SubjectPublicKeysMutation) ResetIssuerPublicKeyID() {
	m.issuer_public_key_id = nil
	m.clearedissuer_public_key_id = false
}

// Where appends a list predicates to the SubjectPublicKeysMutation builder.
func (m *SubjectPublicKeysMutation) Where(ps ...predicate.SubjectPublicKeys) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubjectPublicKeysMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubjectPublicKeysMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubjectPublicKeys, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubjectPublicKeysMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubjectPublicKeysMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubjectPublicKeys).
func (m *SubjectPublicKeysMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubjectPublicKeysMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubjectPublicKeysMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubjectPublicKeysMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown SubjectPublicKeys field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectPublicKeysMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SubjectPublicKeys field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubjectPublicKeysMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubjectPublicKeysMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubjectPublicKeysMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown SubjectPublicKeys numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubjectPublicKeysMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubjectPublicKeysMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubjectPublicKeysMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SubjectPublicKeys nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubjectPublicKeysMutation) ResetField(name string) error {
	return fmt.Errorf("unknown SubjectPublicKeys field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubjectPublicKeysMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.public_key_scope != nil {
		edges = append(edges, subjectpublickeys.EdgePublicKeyScope)
	}
	if m.issuer_public_key_id != nil {
		edges = append(edges, subjectpublickeys.EdgeIssuerPublicKeyID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubjectPublicKeysMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subjectpublickeys.EdgePublicKeyScope:
		if id := m.public_key_scope; id != nil {
			return []ent.Value{*id}
		}
	case subjectpublickeys.EdgeIssuerPublicKeyID:
		if id := m.issuer_public_key_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubjectPublicKeysMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubjectPublicKeysMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubjectPublicKeysMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpublic_key_scope {
		edges = append(edges, subjectpublickeys.EdgePublicKeyScope)
	}
	if m.clearedissuer_public_key_id {
		edges = append(edges, subjectpublickeys.EdgeIssuerPublicKeyID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubjectPublicKeysMutation) EdgeCleared(name string) bool {
	switch name {
	case subjectpublickeys.EdgePublicKeyScope:
		return m.clearedpublic_key_scope
	case subjectpublickeys.EdgeIssuerPublicKeyID:
		return m.clearedissuer_public_key_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubjectPublicKeysMutation) ClearEdge(name string) error {
	switch name {
	case subjectpublickeys.EdgePublicKeyScope:
		m.ClearPublicKeyScope()
		return nil
	case subjectpublickeys.EdgeIssuerPublicKeyID:
		m.ClearIssuerPublicKeyID()
		return nil
	}
	return fmt.Errorf("unknown SubjectPublicKeys unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubjectPublicKeysMutation) ResetEdge(name string) error {
	switch name {
	case subjectpublickeys.EdgePublicKeyScope:
		m.ResetPublicKeyScope()
		return nil
	case subjectpublickeys.EdgeIssuerPublicKeyID:
		m.ResetIssuerPublicKeyID()
		return nil
	}
	return fmt.Errorf("unknown SubjectPublicKeys edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	password      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
