// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"authorization-service/ent/migrate"

	"authorization-service/ent/accesstokens"
	"authorization-service/ent/authorizecodes"
	"authorization-service/ent/blacklistedjtis"
	"authorization-service/ent/clients"
	"authorization-service/ent/idsessions"
	"authorization-service/ent/issuerpublickeys"
	"authorization-service/ent/pkces"
	"authorization-service/ent/publickeyscopes"
	"authorization-service/ent/refreshtokens"
	"authorization-service/ent/request"
	"authorization-service/ent/session"
	"authorization-service/ent/subjectpublickeys"
	"authorization-service/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AccessTokens is the client for interacting with the AccessTokens builders.
	AccessTokens *AccessTokensClient
	// AuthorizeCodes is the client for interacting with the AuthorizeCodes builders.
	AuthorizeCodes *AuthorizeCodesClient
	// BlacklistedJTIs is the client for interacting with the BlacklistedJTIs builders.
	BlacklistedJTIs *BlacklistedJTIsClient
	// Clients is the client for interacting with the Clients builders.
	Clients *ClientsClient
	// IDSessions is the client for interacting with the IDSessions builders.
	IDSessions *IDSessionsClient
	// IssuerPublicKeys is the client for interacting with the IssuerPublicKeys builders.
	IssuerPublicKeys *IssuerPublicKeysClient
	// PKCES is the client for interacting with the PKCES builders.
	PKCES *PKCESClient
	// PublicKeyScopes is the client for interacting with the PublicKeyScopes builders.
	PublicKeyScopes *PublicKeyScopesClient
	// RefreshTokens is the client for interacting with the RefreshTokens builders.
	RefreshTokens *RefreshTokensClient
	// Request is the client for interacting with the Request builders.
	Request *RequestClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// SubjectPublicKeys is the client for interacting with the SubjectPublicKeys builders.
	SubjectPublicKeys *SubjectPublicKeysClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AccessTokens = NewAccessTokensClient(c.config)
	c.AuthorizeCodes = NewAuthorizeCodesClient(c.config)
	c.BlacklistedJTIs = NewBlacklistedJTIsClient(c.config)
	c.Clients = NewClientsClient(c.config)
	c.IDSessions = NewIDSessionsClient(c.config)
	c.IssuerPublicKeys = NewIssuerPublicKeysClient(c.config)
	c.PKCES = NewPKCESClient(c.config)
	c.PublicKeyScopes = NewPublicKeyScopesClient(c.config)
	c.RefreshTokens = NewRefreshTokensClient(c.config)
	c.Request = NewRequestClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.SubjectPublicKeys = NewSubjectPublicKeysClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AccessTokens:      NewAccessTokensClient(cfg),
		AuthorizeCodes:    NewAuthorizeCodesClient(cfg),
		BlacklistedJTIs:   NewBlacklistedJTIsClient(cfg),
		Clients:           NewClientsClient(cfg),
		IDSessions:        NewIDSessionsClient(cfg),
		IssuerPublicKeys:  NewIssuerPublicKeysClient(cfg),
		PKCES:             NewPKCESClient(cfg),
		PublicKeyScopes:   NewPublicKeyScopesClient(cfg),
		RefreshTokens:     NewRefreshTokensClient(cfg),
		Request:           NewRequestClient(cfg),
		Session:           NewSessionClient(cfg),
		SubjectPublicKeys: NewSubjectPublicKeysClient(cfg),
		User:              NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		AccessTokens:      NewAccessTokensClient(cfg),
		AuthorizeCodes:    NewAuthorizeCodesClient(cfg),
		BlacklistedJTIs:   NewBlacklistedJTIsClient(cfg),
		Clients:           NewClientsClient(cfg),
		IDSessions:        NewIDSessionsClient(cfg),
		IssuerPublicKeys:  NewIssuerPublicKeysClient(cfg),
		PKCES:             NewPKCESClient(cfg),
		PublicKeyScopes:   NewPublicKeyScopesClient(cfg),
		RefreshTokens:     NewRefreshTokensClient(cfg),
		Request:           NewRequestClient(cfg),
		Session:           NewSessionClient(cfg),
		SubjectPublicKeys: NewSubjectPublicKeysClient(cfg),
		User:              NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AccessTokens.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AccessTokens, c.AuthorizeCodes, c.BlacklistedJTIs, c.Clients, c.IDSessions,
		c.IssuerPublicKeys, c.PKCES, c.PublicKeyScopes, c.RefreshTokens, c.Request,
		c.Session, c.SubjectPublicKeys, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AccessTokens, c.AuthorizeCodes, c.BlacklistedJTIs, c.Clients, c.IDSessions,
		c.IssuerPublicKeys, c.PKCES, c.PublicKeyScopes, c.RefreshTokens, c.Request,
		c.Session, c.SubjectPublicKeys, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccessTokensMutation:
		return c.AccessTokens.mutate(ctx, m)
	case *AuthorizeCodesMutation:
		return c.AuthorizeCodes.mutate(ctx, m)
	case *BlacklistedJTIsMutation:
		return c.BlacklistedJTIs.mutate(ctx, m)
	case *ClientsMutation:
		return c.Clients.mutate(ctx, m)
	case *IDSessionsMutation:
		return c.IDSessions.mutate(ctx, m)
	case *IssuerPublicKeysMutation:
		return c.IssuerPublicKeys.mutate(ctx, m)
	case *PKCESMutation:
		return c.PKCES.mutate(ctx, m)
	case *PublicKeyScopesMutation:
		return c.PublicKeyScopes.mutate(ctx, m)
	case *RefreshTokensMutation:
		return c.RefreshTokens.mutate(ctx, m)
	case *RequestMutation:
		return c.Request.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *SubjectPublicKeysMutation:
		return c.SubjectPublicKeys.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AccessTokensClient is a client for the AccessTokens schema.
type AccessTokensClient struct {
	config
}

// NewAccessTokensClient returns a client for the AccessTokens from the given config.
func NewAccessTokensClient(c config) *AccessTokensClient {
	return &AccessTokensClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accesstokens.Hooks(f(g(h())))`.
func (c *AccessTokensClient) Use(hooks ...Hook) {
	c.hooks.AccessTokens = append(c.hooks.AccessTokens, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accesstokens.Intercept(f(g(h())))`.
func (c *AccessTokensClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccessTokens = append(c.inters.AccessTokens, interceptors...)
}

// Create returns a builder for creating a AccessTokens entity.
func (c *AccessTokensClient) Create() *AccessTokensCreate {
	mutation := newAccessTokensMutation(c.config, OpCreate)
	return &AccessTokensCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccessTokens entities.
func (c *AccessTokensClient) CreateBulk(builders ...*AccessTokensCreate) *AccessTokensCreateBulk {
	return &AccessTokensCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccessTokens.
func (c *AccessTokensClient) Update() *AccessTokensUpdate {
	mutation := newAccessTokensMutation(c.config, OpUpdate)
	return &AccessTokensUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccessTokensClient) UpdateOne(at *AccessTokens) *AccessTokensUpdateOne {
	mutation := newAccessTokensMutation(c.config, OpUpdateOne, withAccessTokens(at))
	return &AccessTokensUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccessTokensClient) UpdateOneID(id string) *AccessTokensUpdateOne {
	mutation := newAccessTokensMutation(c.config, OpUpdateOne, withAccessTokensID(id))
	return &AccessTokensUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccessTokens.
func (c *AccessTokensClient) Delete() *AccessTokensDelete {
	mutation := newAccessTokensMutation(c.config, OpDelete)
	return &AccessTokensDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccessTokensClient) DeleteOne(at *AccessTokens) *AccessTokensDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccessTokensClient) DeleteOneID(id string) *AccessTokensDeleteOne {
	builder := c.Delete().Where(accesstokens.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccessTokensDeleteOne{builder}
}

// Query returns a query builder for AccessTokens.
func (c *AccessTokensClient) Query() *AccessTokensQuery {
	return &AccessTokensQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccessTokens},
		inters: c.Interceptors(),
	}
}

// Get returns a AccessTokens entity by its id.
func (c *AccessTokensClient) Get(ctx context.Context, id string) (*AccessTokens, error) {
	return c.Query().Where(accesstokens.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccessTokensClient) GetX(ctx context.Context, id string) *AccessTokens {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequestID queries the request_id edge of a AccessTokens.
func (c *AccessTokensClient) QueryRequestID(at *AccessTokens) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accesstokens.Table, accesstokens.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, accesstokens.RequestIDTable, accesstokens.RequestIDColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccessTokensClient) Hooks() []Hook {
	return c.hooks.AccessTokens
}

// Interceptors returns the client interceptors.
func (c *AccessTokensClient) Interceptors() []Interceptor {
	return c.inters.AccessTokens
}

func (c *AccessTokensClient) mutate(ctx context.Context, m *AccessTokensMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccessTokensCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccessTokensUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccessTokensUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccessTokensDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AccessTokens mutation op: %q", m.Op())
	}
}

// AuthorizeCodesClient is a client for the AuthorizeCodes schema.
type AuthorizeCodesClient struct {
	config
}

// NewAuthorizeCodesClient returns a client for the AuthorizeCodes from the given config.
func NewAuthorizeCodesClient(c config) *AuthorizeCodesClient {
	return &AuthorizeCodesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authorizecodes.Hooks(f(g(h())))`.
func (c *AuthorizeCodesClient) Use(hooks ...Hook) {
	c.hooks.AuthorizeCodes = append(c.hooks.AuthorizeCodes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authorizecodes.Intercept(f(g(h())))`.
func (c *AuthorizeCodesClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthorizeCodes = append(c.inters.AuthorizeCodes, interceptors...)
}

// Create returns a builder for creating a AuthorizeCodes entity.
func (c *AuthorizeCodesClient) Create() *AuthorizeCodesCreate {
	mutation := newAuthorizeCodesMutation(c.config, OpCreate)
	return &AuthorizeCodesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthorizeCodes entities.
func (c *AuthorizeCodesClient) CreateBulk(builders ...*AuthorizeCodesCreate) *AuthorizeCodesCreateBulk {
	return &AuthorizeCodesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthorizeCodes.
func (c *AuthorizeCodesClient) Update() *AuthorizeCodesUpdate {
	mutation := newAuthorizeCodesMutation(c.config, OpUpdate)
	return &AuthorizeCodesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthorizeCodesClient) UpdateOne(ac *AuthorizeCodes) *AuthorizeCodesUpdateOne {
	mutation := newAuthorizeCodesMutation(c.config, OpUpdateOne, withAuthorizeCodes(ac))
	return &AuthorizeCodesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthorizeCodesClient) UpdateOneID(id string) *AuthorizeCodesUpdateOne {
	mutation := newAuthorizeCodesMutation(c.config, OpUpdateOne, withAuthorizeCodesID(id))
	return &AuthorizeCodesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthorizeCodes.
func (c *AuthorizeCodesClient) Delete() *AuthorizeCodesDelete {
	mutation := newAuthorizeCodesMutation(c.config, OpDelete)
	return &AuthorizeCodesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthorizeCodesClient) DeleteOne(ac *AuthorizeCodes) *AuthorizeCodesDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthorizeCodesClient) DeleteOneID(id string) *AuthorizeCodesDeleteOne {
	builder := c.Delete().Where(authorizecodes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthorizeCodesDeleteOne{builder}
}

// Query returns a query builder for AuthorizeCodes.
func (c *AuthorizeCodesClient) Query() *AuthorizeCodesQuery {
	return &AuthorizeCodesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthorizeCodes},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthorizeCodes entity by its id.
func (c *AuthorizeCodesClient) Get(ctx context.Context, id string) (*AuthorizeCodes, error) {
	return c.Query().Where(authorizecodes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthorizeCodesClient) GetX(ctx context.Context, id string) *AuthorizeCodes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequestID queries the request_id edge of a AuthorizeCodes.
func (c *AuthorizeCodesClient) QueryRequestID(ac *AuthorizeCodes) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ac.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(authorizecodes.Table, authorizecodes.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, authorizecodes.RequestIDTable, authorizecodes.RequestIDColumn),
		)
		fromV = sqlgraph.Neighbors(ac.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AuthorizeCodesClient) Hooks() []Hook {
	return c.hooks.AuthorizeCodes
}

// Interceptors returns the client interceptors.
func (c *AuthorizeCodesClient) Interceptors() []Interceptor {
	return c.inters.AuthorizeCodes
}

func (c *AuthorizeCodesClient) mutate(ctx context.Context, m *AuthorizeCodesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthorizeCodesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthorizeCodesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthorizeCodesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthorizeCodesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthorizeCodes mutation op: %q", m.Op())
	}
}

// BlacklistedJTIsClient is a client for the BlacklistedJTIs schema.
type BlacklistedJTIsClient struct {
	config
}

// NewBlacklistedJTIsClient returns a client for the BlacklistedJTIs from the given config.
func NewBlacklistedJTIsClient(c config) *BlacklistedJTIsClient {
	return &BlacklistedJTIsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blacklistedjtis.Hooks(f(g(h())))`.
func (c *BlacklistedJTIsClient) Use(hooks ...Hook) {
	c.hooks.BlacklistedJTIs = append(c.hooks.BlacklistedJTIs, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blacklistedjtis.Intercept(f(g(h())))`.
func (c *BlacklistedJTIsClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlacklistedJTIs = append(c.inters.BlacklistedJTIs, interceptors...)
}

// Create returns a builder for creating a BlacklistedJTIs entity.
func (c *BlacklistedJTIsClient) Create() *BlacklistedJTIsCreate {
	mutation := newBlacklistedJTIsMutation(c.config, OpCreate)
	return &BlacklistedJTIsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlacklistedJTIs entities.
func (c *BlacklistedJTIsClient) CreateBulk(builders ...*BlacklistedJTIsCreate) *BlacklistedJTIsCreateBulk {
	return &BlacklistedJTIsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlacklistedJTIs.
func (c *BlacklistedJTIsClient) Update() *BlacklistedJTIsUpdate {
	mutation := newBlacklistedJTIsMutation(c.config, OpUpdate)
	return &BlacklistedJTIsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlacklistedJTIsClient) UpdateOne(bji *BlacklistedJTIs) *BlacklistedJTIsUpdateOne {
	mutation := newBlacklistedJTIsMutation(c.config, OpUpdateOne, withBlacklistedJTIs(bji))
	return &BlacklistedJTIsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlacklistedJTIsClient) UpdateOneID(id string) *BlacklistedJTIsUpdateOne {
	mutation := newBlacklistedJTIsMutation(c.config, OpUpdateOne, withBlacklistedJTIsID(id))
	return &BlacklistedJTIsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlacklistedJTIs.
func (c *BlacklistedJTIsClient) Delete() *BlacklistedJTIsDelete {
	mutation := newBlacklistedJTIsMutation(c.config, OpDelete)
	return &BlacklistedJTIsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlacklistedJTIsClient) DeleteOne(bji *BlacklistedJTIs) *BlacklistedJTIsDeleteOne {
	return c.DeleteOneID(bji.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlacklistedJTIsClient) DeleteOneID(id string) *BlacklistedJTIsDeleteOne {
	builder := c.Delete().Where(blacklistedjtis.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlacklistedJTIsDeleteOne{builder}
}

// Query returns a query builder for BlacklistedJTIs.
func (c *BlacklistedJTIsClient) Query() *BlacklistedJTIsQuery {
	return &BlacklistedJTIsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlacklistedJTIs},
		inters: c.Interceptors(),
	}
}

// Get returns a BlacklistedJTIs entity by its id.
func (c *BlacklistedJTIsClient) Get(ctx context.Context, id string) (*BlacklistedJTIs, error) {
	return c.Query().Where(blacklistedjtis.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlacklistedJTIsClient) GetX(ctx context.Context, id string) *BlacklistedJTIs {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BlacklistedJTIsClient) Hooks() []Hook {
	return c.hooks.BlacklistedJTIs
}

// Interceptors returns the client interceptors.
func (c *BlacklistedJTIsClient) Interceptors() []Interceptor {
	return c.inters.BlacklistedJTIs
}

func (c *BlacklistedJTIsClient) mutate(ctx context.Context, m *BlacklistedJTIsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlacklistedJTIsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlacklistedJTIsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlacklistedJTIsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlacklistedJTIsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlacklistedJTIs mutation op: %q", m.Op())
	}
}

// ClientsClient is a client for the Clients schema.
type ClientsClient struct {
	config
}

// NewClientsClient returns a client for the Clients from the given config.
func NewClientsClient(c config) *ClientsClient {
	return &ClientsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clients.Hooks(f(g(h())))`.
func (c *ClientsClient) Use(hooks ...Hook) {
	c.hooks.Clients = append(c.hooks.Clients, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clients.Intercept(f(g(h())))`.
func (c *ClientsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Clients = append(c.inters.Clients, interceptors...)
}

// Create returns a builder for creating a Clients entity.
func (c *ClientsClient) Create() *ClientsCreate {
	mutation := newClientsMutation(c.config, OpCreate)
	return &ClientsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Clients entities.
func (c *ClientsClient) CreateBulk(builders ...*ClientsCreate) *ClientsCreateBulk {
	return &ClientsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Clients.
func (c *ClientsClient) Update() *ClientsUpdate {
	mutation := newClientsMutation(c.config, OpUpdate)
	return &ClientsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClientsClient) UpdateOne(cl *Clients) *ClientsUpdateOne {
	mutation := newClientsMutation(c.config, OpUpdateOne, withClients(cl))
	return &ClientsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClientsClient) UpdateOneID(id string) *ClientsUpdateOne {
	mutation := newClientsMutation(c.config, OpUpdateOne, withClientsID(id))
	return &ClientsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Clients.
func (c *ClientsClient) Delete() *ClientsDelete {
	mutation := newClientsMutation(c.config, OpDelete)
	return &ClientsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClientsClient) DeleteOne(cl *Clients) *ClientsDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClientsClient) DeleteOneID(id string) *ClientsDeleteOne {
	builder := c.Delete().Where(clients.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClientsDeleteOne{builder}
}

// Query returns a query builder for Clients.
func (c *ClientsClient) Query() *ClientsQuery {
	return &ClientsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClients},
		inters: c.Interceptors(),
	}
}

// Get returns a Clients entity by its id.
func (c *ClientsClient) Get(ctx context.Context, id string) (*Clients, error) {
	return c.Query().Where(clients.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClientsClient) GetX(ctx context.Context, id string) *Clients {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequests queries the requests edge of a Clients.
func (c *ClientsClient) QueryRequests(cl *Clients) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clients.Table, clients.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clients.RequestsTable, clients.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClientsClient) Hooks() []Hook {
	return c.hooks.Clients
}

// Interceptors returns the client interceptors.
func (c *ClientsClient) Interceptors() []Interceptor {
	return c.inters.Clients
}

func (c *ClientsClient) mutate(ctx context.Context, m *ClientsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClientsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClientsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClientsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClientsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Clients mutation op: %q", m.Op())
	}
}

// IDSessionsClient is a client for the IDSessions schema.
type IDSessionsClient struct {
	config
}

// NewIDSessionsClient returns a client for the IDSessions from the given config.
func NewIDSessionsClient(c config) *IDSessionsClient {
	return &IDSessionsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `idsessions.Hooks(f(g(h())))`.
func (c *IDSessionsClient) Use(hooks ...Hook) {
	c.hooks.IDSessions = append(c.hooks.IDSessions, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `idsessions.Intercept(f(g(h())))`.
func (c *IDSessionsClient) Intercept(interceptors ...Interceptor) {
	c.inters.IDSessions = append(c.inters.IDSessions, interceptors...)
}

// Create returns a builder for creating a IDSessions entity.
func (c *IDSessionsClient) Create() *IDSessionsCreate {
	mutation := newIDSessionsMutation(c.config, OpCreate)
	return &IDSessionsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IDSessions entities.
func (c *IDSessionsClient) CreateBulk(builders ...*IDSessionsCreate) *IDSessionsCreateBulk {
	return &IDSessionsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IDSessions.
func (c *IDSessionsClient) Update() *IDSessionsUpdate {
	mutation := newIDSessionsMutation(c.config, OpUpdate)
	return &IDSessionsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IDSessionsClient) UpdateOne(is *IDSessions) *IDSessionsUpdateOne {
	mutation := newIDSessionsMutation(c.config, OpUpdateOne, withIDSessions(is))
	return &IDSessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IDSessionsClient) UpdateOneID(id string) *IDSessionsUpdateOne {
	mutation := newIDSessionsMutation(c.config, OpUpdateOne, withIDSessionsID(id))
	return &IDSessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IDSessions.
func (c *IDSessionsClient) Delete() *IDSessionsDelete {
	mutation := newIDSessionsMutation(c.config, OpDelete)
	return &IDSessionsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IDSessionsClient) DeleteOne(is *IDSessions) *IDSessionsDeleteOne {
	return c.DeleteOneID(is.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IDSessionsClient) DeleteOneID(id string) *IDSessionsDeleteOne {
	builder := c.Delete().Where(idsessions.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IDSessionsDeleteOne{builder}
}

// Query returns a query builder for IDSessions.
func (c *IDSessionsClient) Query() *IDSessionsQuery {
	return &IDSessionsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIDSessions},
		inters: c.Interceptors(),
	}
}

// Get returns a IDSessions entity by its id.
func (c *IDSessionsClient) Get(ctx context.Context, id string) (*IDSessions, error) {
	return c.Query().Where(idsessions.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IDSessionsClient) GetX(ctx context.Context, id string) *IDSessions {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequestID queries the request_id edge of a IDSessions.
func (c *IDSessionsClient) QueryRequestID(is *IDSessions) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := is.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(idsessions.Table, idsessions.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, idsessions.RequestIDTable, idsessions.RequestIDColumn),
		)
		fromV = sqlgraph.Neighbors(is.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IDSessionsClient) Hooks() []Hook {
	return c.hooks.IDSessions
}

// Interceptors returns the client interceptors.
func (c *IDSessionsClient) Interceptors() []Interceptor {
	return c.inters.IDSessions
}

func (c *IDSessionsClient) mutate(ctx context.Context, m *IDSessionsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IDSessionsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IDSessionsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IDSessionsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IDSessionsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IDSessions mutation op: %q", m.Op())
	}
}

// IssuerPublicKeysClient is a client for the IssuerPublicKeys schema.
type IssuerPublicKeysClient struct {
	config
}

// NewIssuerPublicKeysClient returns a client for the IssuerPublicKeys from the given config.
func NewIssuerPublicKeysClient(c config) *IssuerPublicKeysClient {
	return &IssuerPublicKeysClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `issuerpublickeys.Hooks(f(g(h())))`.
func (c *IssuerPublicKeysClient) Use(hooks ...Hook) {
	c.hooks.IssuerPublicKeys = append(c.hooks.IssuerPublicKeys, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `issuerpublickeys.Intercept(f(g(h())))`.
func (c *IssuerPublicKeysClient) Intercept(interceptors ...Interceptor) {
	c.inters.IssuerPublicKeys = append(c.inters.IssuerPublicKeys, interceptors...)
}

// Create returns a builder for creating a IssuerPublicKeys entity.
func (c *IssuerPublicKeysClient) Create() *IssuerPublicKeysCreate {
	mutation := newIssuerPublicKeysMutation(c.config, OpCreate)
	return &IssuerPublicKeysCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of IssuerPublicKeys entities.
func (c *IssuerPublicKeysClient) CreateBulk(builders ...*IssuerPublicKeysCreate) *IssuerPublicKeysCreateBulk {
	return &IssuerPublicKeysCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for IssuerPublicKeys.
func (c *IssuerPublicKeysClient) Update() *IssuerPublicKeysUpdate {
	mutation := newIssuerPublicKeysMutation(c.config, OpUpdate)
	return &IssuerPublicKeysUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *IssuerPublicKeysClient) UpdateOne(ipk *IssuerPublicKeys) *IssuerPublicKeysUpdateOne {
	mutation := newIssuerPublicKeysMutation(c.config, OpUpdateOne, withIssuerPublicKeys(ipk))
	return &IssuerPublicKeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *IssuerPublicKeysClient) UpdateOneID(id string) *IssuerPublicKeysUpdateOne {
	mutation := newIssuerPublicKeysMutation(c.config, OpUpdateOne, withIssuerPublicKeysID(id))
	return &IssuerPublicKeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for IssuerPublicKeys.
func (c *IssuerPublicKeysClient) Delete() *IssuerPublicKeysDelete {
	mutation := newIssuerPublicKeysMutation(c.config, OpDelete)
	return &IssuerPublicKeysDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *IssuerPublicKeysClient) DeleteOne(ipk *IssuerPublicKeys) *IssuerPublicKeysDeleteOne {
	return c.DeleteOneID(ipk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *IssuerPublicKeysClient) DeleteOneID(id string) *IssuerPublicKeysDeleteOne {
	builder := c.Delete().Where(issuerpublickeys.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &IssuerPublicKeysDeleteOne{builder}
}

// Query returns a query builder for IssuerPublicKeys.
func (c *IssuerPublicKeysClient) Query() *IssuerPublicKeysQuery {
	return &IssuerPublicKeysQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeIssuerPublicKeys},
		inters: c.Interceptors(),
	}
}

// Get returns a IssuerPublicKeys entity by its id.
func (c *IssuerPublicKeysClient) Get(ctx context.Context, id string) (*IssuerPublicKeys, error) {
	return c.Query().Where(issuerpublickeys.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *IssuerPublicKeysClient) GetX(ctx context.Context, id string) *IssuerPublicKeys {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubjectPublicKey queries the subject_public_key edge of a IssuerPublicKeys.
func (c *IssuerPublicKeysClient) QuerySubjectPublicKey(ipk *IssuerPublicKeys) *SubjectPublicKeysQuery {
	query := (&SubjectPublicKeysClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ipk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(issuerpublickeys.Table, issuerpublickeys.FieldID, id),
			sqlgraph.To(subjectpublickeys.Table, subjectpublickeys.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, issuerpublickeys.SubjectPublicKeyTable, issuerpublickeys.SubjectPublicKeyColumn),
		)
		fromV = sqlgraph.Neighbors(ipk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *IssuerPublicKeysClient) Hooks() []Hook {
	return c.hooks.IssuerPublicKeys
}

// Interceptors returns the client interceptors.
func (c *IssuerPublicKeysClient) Interceptors() []Interceptor {
	return c.inters.IssuerPublicKeys
}

func (c *IssuerPublicKeysClient) mutate(ctx context.Context, m *IssuerPublicKeysMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&IssuerPublicKeysCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&IssuerPublicKeysUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&IssuerPublicKeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&IssuerPublicKeysDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown IssuerPublicKeys mutation op: %q", m.Op())
	}
}

// PKCESClient is a client for the PKCES schema.
type PKCESClient struct {
	config
}

// NewPKCESClient returns a client for the PKCES from the given config.
func NewPKCESClient(c config) *PKCESClient {
	return &PKCESClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pkces.Hooks(f(g(h())))`.
func (c *PKCESClient) Use(hooks ...Hook) {
	c.hooks.PKCES = append(c.hooks.PKCES, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pkces.Intercept(f(g(h())))`.
func (c *PKCESClient) Intercept(interceptors ...Interceptor) {
	c.inters.PKCES = append(c.inters.PKCES, interceptors...)
}

// Create returns a builder for creating a PKCES entity.
func (c *PKCESClient) Create() *PKCESCreate {
	mutation := newPKCESMutation(c.config, OpCreate)
	return &PKCESCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PKCES entities.
func (c *PKCESClient) CreateBulk(builders ...*PKCESCreate) *PKCESCreateBulk {
	return &PKCESCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PKCES.
func (c *PKCESClient) Update() *PKCESUpdate {
	mutation := newPKCESMutation(c.config, OpUpdate)
	return &PKCESUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PKCESClient) UpdateOne(pk *PKCES) *PKCESUpdateOne {
	mutation := newPKCESMutation(c.config, OpUpdateOne, withPKCES(pk))
	return &PKCESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PKCESClient) UpdateOneID(id string) *PKCESUpdateOne {
	mutation := newPKCESMutation(c.config, OpUpdateOne, withPKCESID(id))
	return &PKCESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PKCES.
func (c *PKCESClient) Delete() *PKCESDelete {
	mutation := newPKCESMutation(c.config, OpDelete)
	return &PKCESDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PKCESClient) DeleteOne(pk *PKCES) *PKCESDeleteOne {
	return c.DeleteOneID(pk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PKCESClient) DeleteOneID(id string) *PKCESDeleteOne {
	builder := c.Delete().Where(pkces.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PKCESDeleteOne{builder}
}

// Query returns a query builder for PKCES.
func (c *PKCESClient) Query() *PKCESQuery {
	return &PKCESQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePKCES},
		inters: c.Interceptors(),
	}
}

// Get returns a PKCES entity by its id.
func (c *PKCESClient) Get(ctx context.Context, id string) (*PKCES, error) {
	return c.Query().Where(pkces.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PKCESClient) GetX(ctx context.Context, id string) *PKCES {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequestID queries the request_id edge of a PKCES.
func (c *PKCESClient) QueryRequestID(pk *PKCES) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pkces.Table, pkces.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, pkces.RequestIDTable, pkces.RequestIDColumn),
		)
		fromV = sqlgraph.Neighbors(pk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PKCESClient) Hooks() []Hook {
	return c.hooks.PKCES
}

// Interceptors returns the client interceptors.
func (c *PKCESClient) Interceptors() []Interceptor {
	return c.inters.PKCES
}

func (c *PKCESClient) mutate(ctx context.Context, m *PKCESMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PKCESCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PKCESUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PKCESUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PKCESDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PKCES mutation op: %q", m.Op())
	}
}

// PublicKeyScopesClient is a client for the PublicKeyScopes schema.
type PublicKeyScopesClient struct {
	config
}

// NewPublicKeyScopesClient returns a client for the PublicKeyScopes from the given config.
func NewPublicKeyScopesClient(c config) *PublicKeyScopesClient {
	return &PublicKeyScopesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `publickeyscopes.Hooks(f(g(h())))`.
func (c *PublicKeyScopesClient) Use(hooks ...Hook) {
	c.hooks.PublicKeyScopes = append(c.hooks.PublicKeyScopes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `publickeyscopes.Intercept(f(g(h())))`.
func (c *PublicKeyScopesClient) Intercept(interceptors ...Interceptor) {
	c.inters.PublicKeyScopes = append(c.inters.PublicKeyScopes, interceptors...)
}

// Create returns a builder for creating a PublicKeyScopes entity.
func (c *PublicKeyScopesClient) Create() *PublicKeyScopesCreate {
	mutation := newPublicKeyScopesMutation(c.config, OpCreate)
	return &PublicKeyScopesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PublicKeyScopes entities.
func (c *PublicKeyScopesClient) CreateBulk(builders ...*PublicKeyScopesCreate) *PublicKeyScopesCreateBulk {
	return &PublicKeyScopesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PublicKeyScopes.
func (c *PublicKeyScopesClient) Update() *PublicKeyScopesUpdate {
	mutation := newPublicKeyScopesMutation(c.config, OpUpdate)
	return &PublicKeyScopesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PublicKeyScopesClient) UpdateOne(pks *PublicKeyScopes) *PublicKeyScopesUpdateOne {
	mutation := newPublicKeyScopesMutation(c.config, OpUpdateOne, withPublicKeyScopes(pks))
	return &PublicKeyScopesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PublicKeyScopesClient) UpdateOneID(id string) *PublicKeyScopesUpdateOne {
	mutation := newPublicKeyScopesMutation(c.config, OpUpdateOne, withPublicKeyScopesID(id))
	return &PublicKeyScopesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PublicKeyScopes.
func (c *PublicKeyScopesClient) Delete() *PublicKeyScopesDelete {
	mutation := newPublicKeyScopesMutation(c.config, OpDelete)
	return &PublicKeyScopesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PublicKeyScopesClient) DeleteOne(pks *PublicKeyScopes) *PublicKeyScopesDeleteOne {
	return c.DeleteOneID(pks.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PublicKeyScopesClient) DeleteOneID(id string) *PublicKeyScopesDeleteOne {
	builder := c.Delete().Where(publickeyscopes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PublicKeyScopesDeleteOne{builder}
}

// Query returns a query builder for PublicKeyScopes.
func (c *PublicKeyScopesClient) Query() *PublicKeyScopesQuery {
	return &PublicKeyScopesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePublicKeyScopes},
		inters: c.Interceptors(),
	}
}

// Get returns a PublicKeyScopes entity by its id.
func (c *PublicKeyScopesClient) Get(ctx context.Context, id string) (*PublicKeyScopes, error) {
	return c.Query().Where(publickeyscopes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PublicKeyScopesClient) GetX(ctx context.Context, id string) *PublicKeyScopes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubjectPublicKeyID queries the subject_public_key_id edge of a PublicKeyScopes.
func (c *PublicKeyScopesClient) QuerySubjectPublicKeyID(pks *PublicKeyScopes) *SubjectPublicKeysQuery {
	query := (&SubjectPublicKeysClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pks.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(publickeyscopes.Table, publickeyscopes.FieldID, id),
			sqlgraph.To(subjectpublickeys.Table, subjectpublickeys.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, publickeyscopes.SubjectPublicKeyIDTable, publickeyscopes.SubjectPublicKeyIDColumn),
		)
		fromV = sqlgraph.Neighbors(pks.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PublicKeyScopesClient) Hooks() []Hook {
	return c.hooks.PublicKeyScopes
}

// Interceptors returns the client interceptors.
func (c *PublicKeyScopesClient) Interceptors() []Interceptor {
	return c.inters.PublicKeyScopes
}

func (c *PublicKeyScopesClient) mutate(ctx context.Context, m *PublicKeyScopesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PublicKeyScopesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PublicKeyScopesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PublicKeyScopesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PublicKeyScopesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PublicKeyScopes mutation op: %q", m.Op())
	}
}

// RefreshTokensClient is a client for the RefreshTokens schema.
type RefreshTokensClient struct {
	config
}

// NewRefreshTokensClient returns a client for the RefreshTokens from the given config.
func NewRefreshTokensClient(c config) *RefreshTokensClient {
	return &RefreshTokensClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `refreshtokens.Hooks(f(g(h())))`.
func (c *RefreshTokensClient) Use(hooks ...Hook) {
	c.hooks.RefreshTokens = append(c.hooks.RefreshTokens, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `refreshtokens.Intercept(f(g(h())))`.
func (c *RefreshTokensClient) Intercept(interceptors ...Interceptor) {
	c.inters.RefreshTokens = append(c.inters.RefreshTokens, interceptors...)
}

// Create returns a builder for creating a RefreshTokens entity.
func (c *RefreshTokensClient) Create() *RefreshTokensCreate {
	mutation := newRefreshTokensMutation(c.config, OpCreate)
	return &RefreshTokensCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RefreshTokens entities.
func (c *RefreshTokensClient) CreateBulk(builders ...*RefreshTokensCreate) *RefreshTokensCreateBulk {
	return &RefreshTokensCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RefreshTokens.
func (c *RefreshTokensClient) Update() *RefreshTokensUpdate {
	mutation := newRefreshTokensMutation(c.config, OpUpdate)
	return &RefreshTokensUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RefreshTokensClient) UpdateOne(rt *RefreshTokens) *RefreshTokensUpdateOne {
	mutation := newRefreshTokensMutation(c.config, OpUpdateOne, withRefreshTokens(rt))
	return &RefreshTokensUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RefreshTokensClient) UpdateOneID(id string) *RefreshTokensUpdateOne {
	mutation := newRefreshTokensMutation(c.config, OpUpdateOne, withRefreshTokensID(id))
	return &RefreshTokensUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RefreshTokens.
func (c *RefreshTokensClient) Delete() *RefreshTokensDelete {
	mutation := newRefreshTokensMutation(c.config, OpDelete)
	return &RefreshTokensDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RefreshTokensClient) DeleteOne(rt *RefreshTokens) *RefreshTokensDeleteOne {
	return c.DeleteOneID(rt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RefreshTokensClient) DeleteOneID(id string) *RefreshTokensDeleteOne {
	builder := c.Delete().Where(refreshtokens.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RefreshTokensDeleteOne{builder}
}

// Query returns a query builder for RefreshTokens.
func (c *RefreshTokensClient) Query() *RefreshTokensQuery {
	return &RefreshTokensQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRefreshTokens},
		inters: c.Interceptors(),
	}
}

// Get returns a RefreshTokens entity by its id.
func (c *RefreshTokensClient) Get(ctx context.Context, id string) (*RefreshTokens, error) {
	return c.Query().Where(refreshtokens.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RefreshTokensClient) GetX(ctx context.Context, id string) *RefreshTokens {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequestID queries the request_id edge of a RefreshTokens.
func (c *RefreshTokensClient) QueryRequestID(rt *RefreshTokens) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(refreshtokens.Table, refreshtokens.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, refreshtokens.RequestIDTable, refreshtokens.RequestIDColumn),
		)
		fromV = sqlgraph.Neighbors(rt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RefreshTokensClient) Hooks() []Hook {
	return c.hooks.RefreshTokens
}

// Interceptors returns the client interceptors.
func (c *RefreshTokensClient) Interceptors() []Interceptor {
	return c.inters.RefreshTokens
}

func (c *RefreshTokensClient) mutate(ctx context.Context, m *RefreshTokensMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RefreshTokensCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RefreshTokensUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RefreshTokensUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RefreshTokensDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RefreshTokens mutation op: %q", m.Op())
	}
}

// RequestClient is a client for the Request schema.
type RequestClient struct {
	config
}

// NewRequestClient returns a client for the Request from the given config.
func NewRequestClient(c config) *RequestClient {
	return &RequestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `request.Hooks(f(g(h())))`.
func (c *RequestClient) Use(hooks ...Hook) {
	c.hooks.Request = append(c.hooks.Request, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `request.Intercept(f(g(h())))`.
func (c *RequestClient) Intercept(interceptors ...Interceptor) {
	c.inters.Request = append(c.inters.Request, interceptors...)
}

// Create returns a builder for creating a Request entity.
func (c *RequestClient) Create() *RequestCreate {
	mutation := newRequestMutation(c.config, OpCreate)
	return &RequestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Request entities.
func (c *RequestClient) CreateBulk(builders ...*RequestCreate) *RequestCreateBulk {
	return &RequestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Request.
func (c *RequestClient) Update() *RequestUpdate {
	mutation := newRequestMutation(c.config, OpUpdate)
	return &RequestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RequestClient) UpdateOne(r *Request) *RequestUpdateOne {
	mutation := newRequestMutation(c.config, OpUpdateOne, withRequest(r))
	return &RequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RequestClient) UpdateOneID(id string) *RequestUpdateOne {
	mutation := newRequestMutation(c.config, OpUpdateOne, withRequestID(id))
	return &RequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Request.
func (c *RequestClient) Delete() *RequestDelete {
	mutation := newRequestMutation(c.config, OpDelete)
	return &RequestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RequestClient) DeleteOne(r *Request) *RequestDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RequestClient) DeleteOneID(id string) *RequestDeleteOne {
	builder := c.Delete().Where(request.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RequestDeleteOne{builder}
}

// Query returns a query builder for Request.
func (c *RequestClient) Query() *RequestQuery {
	return &RequestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRequest},
		inters: c.Interceptors(),
	}
}

// Get returns a Request entity by its id.
func (c *RequestClient) Get(ctx context.Context, id string) (*Request, error) {
	return c.Query().Where(request.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RequestClient) GetX(ctx context.Context, id string) *Request {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClientID queries the client_id edge of a Request.
func (c *RequestClient) QueryClientID(r *Request) *ClientsQuery {
	query := (&ClientsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(clients.Table, clients.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.ClientIDTable, request.ClientIDColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessionID queries the session_id edge of a Request.
func (c *RequestClient) QuerySessionID(r *Request) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, request.SessionIDTable, request.SessionIDColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRefreshToken queries the refresh_token edge of a Request.
func (c *RequestClient) QueryRefreshToken(r *Request) *RefreshTokensQuery {
	query := (&RefreshTokensClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(refreshtokens.Table, refreshtokens.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, request.RefreshTokenTable, request.RefreshTokenColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthorizeCode queries the authorize_code edge of a Request.
func (c *RequestClient) QueryAuthorizeCode(r *Request) *AuthorizeCodesQuery {
	query := (&AuthorizeCodesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(authorizecodes.Table, authorizecodes.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, request.AuthorizeCodeTable, request.AuthorizeCodeColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccessToken queries the access_token edge of a Request.
func (c *RequestClient) QueryAccessToken(r *Request) *AccessTokensQuery {
	query := (&AccessTokensClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(accesstokens.Table, accesstokens.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, request.AccessTokenTable, request.AccessTokenColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIDSession queries the id_session edge of a Request.
func (c *RequestClient) QueryIDSession(r *Request) *IDSessionsQuery {
	query := (&IDSessionsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(idsessions.Table, idsessions.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, request.IDSessionTable, request.IDSessionColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPkce queries the pkce edge of a Request.
func (c *RequestClient) QueryPkce(r *Request) *PKCESQuery {
	query := (&PKCESClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(request.Table, request.FieldID, id),
			sqlgraph.To(pkces.Table, pkces.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, request.PkceTable, request.PkceColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RequestClient) Hooks() []Hook {
	return c.hooks.Request
}

// Interceptors returns the client interceptors.
func (c *RequestClient) Interceptors() []Interceptor {
	return c.inters.Request
}

func (c *RequestClient) mutate(ctx context.Context, m *RequestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RequestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RequestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RequestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RequestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Request mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRequests queries the requests edge of a Session.
func (c *SessionClient) QueryRequests(s *Session) *RequestQuery {
	query := (&RequestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(request.Table, request.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, session.RequestsTable, session.RequestsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// SubjectPublicKeysClient is a client for the SubjectPublicKeys schema.
type SubjectPublicKeysClient struct {
	config
}

// NewSubjectPublicKeysClient returns a client for the SubjectPublicKeys from the given config.
func NewSubjectPublicKeysClient(c config) *SubjectPublicKeysClient {
	return &SubjectPublicKeysClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subjectpublickeys.Hooks(f(g(h())))`.
func (c *SubjectPublicKeysClient) Use(hooks ...Hook) {
	c.hooks.SubjectPublicKeys = append(c.hooks.SubjectPublicKeys, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `subjectpublickeys.Intercept(f(g(h())))`.
func (c *SubjectPublicKeysClient) Intercept(interceptors ...Interceptor) {
	c.inters.SubjectPublicKeys = append(c.inters.SubjectPublicKeys, interceptors...)
}

// Create returns a builder for creating a SubjectPublicKeys entity.
func (c *SubjectPublicKeysClient) Create() *SubjectPublicKeysCreate {
	mutation := newSubjectPublicKeysMutation(c.config, OpCreate)
	return &SubjectPublicKeysCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SubjectPublicKeys entities.
func (c *SubjectPublicKeysClient) CreateBulk(builders ...*SubjectPublicKeysCreate) *SubjectPublicKeysCreateBulk {
	return &SubjectPublicKeysCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SubjectPublicKeys.
func (c *SubjectPublicKeysClient) Update() *SubjectPublicKeysUpdate {
	mutation := newSubjectPublicKeysMutation(c.config, OpUpdate)
	return &SubjectPublicKeysUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubjectPublicKeysClient) UpdateOne(spk *SubjectPublicKeys) *SubjectPublicKeysUpdateOne {
	mutation := newSubjectPublicKeysMutation(c.config, OpUpdateOne, withSubjectPublicKeys(spk))
	return &SubjectPublicKeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubjectPublicKeysClient) UpdateOneID(id string) *SubjectPublicKeysUpdateOne {
	mutation := newSubjectPublicKeysMutation(c.config, OpUpdateOne, withSubjectPublicKeysID(id))
	return &SubjectPublicKeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SubjectPublicKeys.
func (c *SubjectPublicKeysClient) Delete() *SubjectPublicKeysDelete {
	mutation := newSubjectPublicKeysMutation(c.config, OpDelete)
	return &SubjectPublicKeysDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SubjectPublicKeysClient) DeleteOne(spk *SubjectPublicKeys) *SubjectPublicKeysDeleteOne {
	return c.DeleteOneID(spk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SubjectPublicKeysClient) DeleteOneID(id string) *SubjectPublicKeysDeleteOne {
	builder := c.Delete().Where(subjectpublickeys.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubjectPublicKeysDeleteOne{builder}
}

// Query returns a query builder for SubjectPublicKeys.
func (c *SubjectPublicKeysClient) Query() *SubjectPublicKeysQuery {
	return &SubjectPublicKeysQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSubjectPublicKeys},
		inters: c.Interceptors(),
	}
}

// Get returns a SubjectPublicKeys entity by its id.
func (c *SubjectPublicKeysClient) Get(ctx context.Context, id string) (*SubjectPublicKeys, error) {
	return c.Query().Where(subjectpublickeys.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubjectPublicKeysClient) GetX(ctx context.Context, id string) *SubjectPublicKeys {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPublicKeyScope queries the public_key_scope edge of a SubjectPublicKeys.
func (c *SubjectPublicKeysClient) QueryPublicKeyScope(spk *SubjectPublicKeys) *PublicKeyScopesQuery {
	query := (&PublicKeyScopesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := spk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subjectpublickeys.Table, subjectpublickeys.FieldID, id),
			sqlgraph.To(publickeyscopes.Table, publickeyscopes.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, subjectpublickeys.PublicKeyScopeTable, subjectpublickeys.PublicKeyScopeColumn),
		)
		fromV = sqlgraph.Neighbors(spk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryIssuerPublicKeyID queries the issuer_public_key_id edge of a SubjectPublicKeys.
func (c *SubjectPublicKeysClient) QueryIssuerPublicKeyID(spk *SubjectPublicKeys) *IssuerPublicKeysQuery {
	query := (&IssuerPublicKeysClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := spk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(subjectpublickeys.Table, subjectpublickeys.FieldID, id),
			sqlgraph.To(issuerpublickeys.Table, issuerpublickeys.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, subjectpublickeys.IssuerPublicKeyIDTable, subjectpublickeys.IssuerPublicKeyIDColumn),
		)
		fromV = sqlgraph.Neighbors(spk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SubjectPublicKeysClient) Hooks() []Hook {
	return c.hooks.SubjectPublicKeys
}

// Interceptors returns the client interceptors.
func (c *SubjectPublicKeysClient) Interceptors() []Interceptor {
	return c.inters.SubjectPublicKeys
}

func (c *SubjectPublicKeysClient) mutate(ctx context.Context, m *SubjectPublicKeysMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SubjectPublicKeysCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SubjectPublicKeysUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SubjectPublicKeysUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SubjectPublicKeysDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SubjectPublicKeys mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AccessTokens, AuthorizeCodes, BlacklistedJTIs, Clients, IDSessions,
		IssuerPublicKeys, PKCES, PublicKeyScopes, RefreshTokens, Request, Session,
		SubjectPublicKeys, User []ent.Hook
	}
	inters struct {
		AccessTokens, AuthorizeCodes, BlacklistedJTIs, Clients, IDSessions,
		IssuerPublicKeys, PKCES, PublicKeyScopes, RefreshTokens, Request, Session,
		SubjectPublicKeys, User []ent.Interceptor
	}
)
